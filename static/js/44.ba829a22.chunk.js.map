{"version":3,"sources":["../../../../src/Popover/usePopoverProviderState.js","utils/randomTreeNodes.js","components/TreeToolbar.js","components/TreeContainer.js","TreeView/customHooks/useTreeProps.js","TreeView/SingleSelect.js","../../../../src/TruncatedTooltipText/TooltipTextProvider.js","../../../../src/TruncatedTooltipText/DSTruncatedTooltipText.js","../../../../src/hooks/useDerivedStateFromProps.js","../../src/timer.js","../../src/domHelpers.js","../../src/createGridComponent.js","../../src/createListComponent.js","../../src/VariableSizeList.js","../../src/FixedSizeList.js","../../src/shallowDiffers.js","../../src/areEqual.js","../../../../../src/form/TextBox/DSTextBox.js","../../../../src/FocusGroup/useFocusGroupItem.js","../../../src/MoreOptionsVert.js","../../../src/Search.js","../../../src/CheckableGroup.js","../../../../../src/form/SearchBox/withSearchable.js","../../../../../src/form/SearchBox/SearchBoxImpl.js","../../../src/ChevronSmallRight.js","../../../src/Checkmark.js","../../../../../src/form/SearchBox/DSSearchBox.js","../../../../src/Icon/DSIconSize.js","../../../../src/Toolbar/decorateToolbarChildren.js","../../../../../src/Menu/MenuItems/Separator.js","../../../../../src/Menu/utils/useHeightByAmountOfItems.js","../../../../src/Menu/VirtualMenuList.js","../../../../src/Menu/MenuContext.js","../../../../../src/Menu/MenuItems/SearchableGroup.js","../../../../../src/Menu/MenuItems/CheckboxGroup.js","../../../../../src/Menu/MenuItems/RadioGroup.js","../../../src/Menu/MenuItems/SubMenu.js","../../../src/Menu/MenuItems/SelectionGroup.js","../../../src/Menu/MenuItems/MenuItemCheckbox.js","../../../src/Menu/MenuItems/menuItemFactory.js","../../../src/Menu/MenuItems/MenuItem.js","../../../src/Menu/MenuItems/MenuItemCheckable.js","../../../src/Menu/MenuItems/MenuItemRadio.js","../../../src/Menu/Menu.js","../../../../src/hooks/useExecutionTimer.js","../../../../src/FocusGroup/focusGroupManagerHoc.js","../../../src/DropdownMenuContext.js","../../../src/DropdownMenuProvider.js","../../../src/MenuItemGroupSelectionHOC.js","../../../src/MenuItemClickableHOC.js","../../../src/decoratedMenuItemFactory.js","../../../src/DropdownMenuLoadingIndicator.js","../../../src/DropdownMenuRenderer.js","../../../src/DropdownMenuWrapper.js","../../../../../ds-basic/src/Popper/positions.js","../../../../../ds-basic/src/Popper/interaction.js","../../../src/DSDropdownMenu.js","../../../../src/Toolbar/DSToolbar.js","../../../../../src/plugins/searchable/SearchableTreePlugin.js"],"names":["initialState","reference","visible","value","options","delay","triggerRef","useRef","useState","tooltipState","setTooltipState","useExecutionTimer","state","prevState","showTooltip","hideTooltip","handleHideTooltip","useEffect","window","throttle","show","e","target","hide","randomEntity","parentID","id","uuidv4","isGroup","random","children","randomEntities","undefined","name","type","parent","count","Array","fill","map","randomEntityNoChildren","randomEntitiesNoChildren","randomEntityMoreGroup","randomEntitiesMoreGroups","getOptions","toggleExpandAll","label","onClick","EllipsisMenu","isOpen","setIsOpen","onOptionsClick","containerProps","onClickOutsideMenu","triggerComponent","buttonType","icon","size","DSIconSizes","M","TreeToolbar","searchQuery","setSearchQuery","withDepth","clearable","onSearch","placeholder","searchOnEnter","margin","orientation","TreeContainer","styled","div","props","offsetHeight","useTreeProps","disableGroups","setDisableGroups","toggleDisableGroups","nodes","onItemClick","item","console","log","SingleSelect","ref","current","actions","expandAll","checked","labelText","onChange","data","fluid","instanceRef","groupIcon","isSingleSelect","itemIcon","plugins","SelectablePluginTree","SearchableTreePlugin","showChildrenAmount","TruncatedTooltipContext","React","Provider","TooltipTextProvider","tooltipDelay","placement","tooltipOptions","usePopoverProviderState","zIndex","setZIndex","useMemo","boundaries","showArrow","content","referenceEl","style","pointerEvents","Text","DSTruncatedTooltipText","otherTextProps","tooltipContext","useContext","handlers","onMouseEnter","onMouseLeave","PropTypes","tooltipPlacement","positions","number","defaultPropUpdateOnChange","prop","defaultShouldUpdate","prevProp","stateValue","isEqual","setStateWithUpdate","onUpdate","setState","isFunction","shouldUpdate","updateOnStateChange","handleSetState","nextProp","now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","requestTimeout","callback","start","requestAnimationFrame","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","outerStyle","innerDiv","innerStyle","defaultItemKey","index","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_instanceProps","_outerRef","_resetIsScrollingTimeoutId","instance","isScrolling","scrollDirection","scrollOffset","scrollUpdateWasRequested","memoizeOne","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","direction","itemSize","layout","itemStyleCache","offset","isHorizontal","isRtl","offsetHorizontal","position","left","right","top","height","width","event","clientWidth","scrollLeft","scrollWidth","Math","clientHeight","scrollHeight","scrollTop","outerRef","validateSharedProps","nextProps","this","align","itemCount","initialScrollOffset","className","innerRef","innerElementType","innerTagName","itemData","itemKey","outerElementType","outerTagName","useIsScrolling","onScroll","startIndex","stopIndex","items","createElement","key","_getItemStyle","estimatedTotalSize","overflow","WebkitOverflowScrolling","willChange","overscanCount","overscanBackward","overscanForward","getItemMetadata","itemMetadataMap","instanceProps","lastMeasuredIndex","itemMetadata","i","findNearestItemBinarySearch","low","middle","high","currentOffset","findNearestItemExponentialSearch","interval","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","maxOffset","minOffset","findNearestItem","shouldForceUpdate","FixedSizeList","lastItemOffset","middleOffset","numVisibleItems","shallowDiffers","prev","attribute","next","areEqual","prevStyle","prevProps","prevRest","nextStyle","nextRest","DSTextBox","autoFocus","disabled","maxLength","minLength","fluidWidth","hasError","readOnly","min","max","leftComponent","rightComponent","required","variant","otherProps","aria-label","role","string","useFocusGroupWithState","register","unregister","otherActions","createIcon","paths","useCheckableGroup","activeProp","active","multi","onCheck","useDerivedStateFromProps","setActive","handleCheck","prevActive","nextActive","addOrRemove","child","cloneElement","runAll","CheckableGroup","func","WrappedComponent","Searchable","debounce","onKeyUp","property","clearOnSearch","query","rest","buttonRef","prevPropValue","SearchBoxImpl","disableButton","showIcon","onBlur","iconSize","borderColor","borderLeft","bool","withSearchable","DSSearchBox","searchIcon","XXS","XS","S","L","XL","XXL","extraProps","component","Li","Title","aggregatedClasses","title","showSeparator","itemHeight","amountItems","amountItemsInWindow","itemsLength","calculateHeight","MenuItem","computedListHeight","useHeightByAmountOfItems","SearchBoxWrapper","NoOptionsWrapper","SearchableGroup","searchTerm","searchTermProp","noOptionsText","focusOnOpen","searchRef","setSearchTerm","setTimeout","filteredChildren","focusGroupManagerHoc","CheckboxGroup","RadioGroup","SubMenu","noAddon","leftAddon","interactionType","subitems","rightAddonType","disabledAddonInactive","checkableProps","customRenderer","closeMenu","itemRef","useHiddenController","interaction","onShow","onHide","focusItemByNode","useFocusGroupItem","hoverHandlers","rightAddon","leftIcon","color","handleShowSubItemsWithMouse","BUTTON_VARIANT","DEFAULT","contentComponent","focusKeyBindings","ArrowLeft","onExitFocusGroup","onOpen","opening","onKeyDown","noop","SelectionGroup","searchable","onSelect","renderedItems","Component","menuItemFactory","decoratedGroupChildren","MenuItemCheckbox","itemTypes","separator","menuitem","radio","checkbox","submenu","fallback","defaultItem","itemsObject","parsedType","renderMenuItems","factory","option","ItemComponent","onMouseDown","Content","Addon","empty","fixedItem","renderAddon","addon","addonId","classProps","renderAddons","addons","Wrapper","calculateSize","length","as","tabIndex","maxOption","menuCxt","wrapperProps","omit","mergeRefs","MouseEvent","view","bubbles","cancelable","maxWidth","MenuItemCheckable","checkIcon","useCheckable","checkAddon","MenuItemRadio","element","MenuComponent","menuComboBox","isChildOfType","DSMenu","MenuTag","animated","ul","onClickOutside","minWidth","responsiveHeight","menuRef","focusFirst","useHiddenTransition","hiddenProps","nextChildren","forceLeftAddon","useOnClickOutside","data-testid","overflowY","maxHeight","WrappedMenu","loop","startFn","cleanFn","delayTime","startTimer","closeTimer","args","clearTimeout","onFocusPrevGroup","keyBindings","onSelectMenuItem","onOpenMenu","onClose","selection","singleGroupSelection","onSelectChange","isMenuOpen","setMenuOpen","useCallback","openMenu","handleItemClick","group","nextSelection","activeState","selectionItem","toggleInObject","handleCloseOnClick","valueProvider","handlerName","restProps","propHandler","handler","get","defaultConfig","config","Menu","MenuItemClickableHOC","MenuItemGroupSelectionHOC","preventOverflow","customMenu","contentOffset","contentStyle","menuProps","referenceNode","focusOnOpenProp","itemsRenderer","loading","setFocusOnOpenMenu","o","String","nestedMax","getMax","optionsRendererd","renderOptions","dropdownBlockName","convertPropToCssClassName","getComponentFromProps","blockName","Position","Interaction","interactions","DSDropdownMenu","ToolbarContainer","alignment","DSToolbar","autoFocusOnMount","containerRef","getContainer","Tab","decorateToolbarChildren"],"mappings":"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","file":"static/js/44.ba829a22.chunk.js","sourcesContent":["import { useState, useEffect, useRef } from 'react';\nimport { throttle } from 'lodash';\nimport { useExecutionTimer } from '@elliemae/ds-utilities/hooks';\n\nfunction usePopoverProviderState({\n  initialState = {\n    reference: null,\n    visible: false,\n    value: '',\n    options: {},\n  },\n  delay,\n}) {\n  const triggerRef = useRef();\n  const [tooltipState, setTooltipState] = useState(initialState);\n\n  const show = state => {\n    setTooltipState(prevState => ({\n      ...prevState,\n      ...state,\n      visible: true,\n    }));\n  };\n  const hide = state => {\n    setTooltipState(prevState => ({\n      ...prevState,\n      ...state,\n      visible: false,\n    }));\n  };\n\n  const [showTooltip, hideTooltip] = useExecutionTimer(show, hide, delay);\n\n  const handleShowTooltip = (state, e) => {\n    triggerRef.current = e.target;\n    showTooltip({ ...state, reference: e.target });\n  };\n\n  const handleHideTooltip = state => {\n    hideTooltip(state);\n  };\n\n  useEffect(() => {\n    window.addEventListener('scroll', throttle(handleHideTooltip, 300), true);\n    window.addEventListener('click', handleHideTooltip, true);\n    return () => {\n      window.removeEventListener(\n        'scroll',\n        throttle(handleHideTooltip, 300),\n        true,\n      );\n      window.addEventListener('click', handleHideTooltip, true);\n    };\n  }, [tooltipState.reference]);\n\n  return {\n    show: handleShowTooltip,\n    hide: handleHideTooltip,\n    state: tooltipState,\n  };\n}\n\nexport default usePopoverProviderState;\n","import { random } from 'lodash';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport const randomEntity = (parentID) => {\n  const id = uuidv4();\n  const isGroup = random(0, 4) < 1;\n  const children = isGroup\n    ? randomEntities(random(0, 5), id)\n    : undefined;\n  return {\n    id,\n    name: `${random(0, 1) > 0 ? 'John Doe' : 'Jon Snow'} ${id}`,\n    type: isGroup ? 'group' : 'single',\n    parent: parentID,\n    children,\n  };\n};\nexport const randomEntities = (count, parentID) =>\n  new Array(count).fill(0).map(() => {\n    return randomEntity(parentID);\n  });\n\n/** With increased chances of getting no children group */\nexport const randomEntityNoChildren = () => {\n  const id = uuidv4();\n  const isGroup = random(0, 4) < 2;\n  let children = isGroup\n    ? randomEntities(random(0, 2), id)\n    : undefined;\n  if (random(0, 4) < 2) children = [];\n  return {\n    id,\n    name: `${random(0, 1) > 0 ? 'John Doe' : 'Jon Snow'} ${id}`,\n    type: isGroup ? 'group' : 'single',\n    children,\n    isGroup,\n  };\n};\n/** With increased chances of getting no children groups */\nexport const randomEntitiesNoChildren = (count) =>\n  new Array(count).fill(0).map(() => {\n    return randomEntityNoChildren();\n  });\n\n/** With increased chances of getting a group */\nexport const randomEntityMoreGroup = () => {\n  const id = uuidv4();\n  const isGroup = random(0, 4) < 3;\n  let children = isGroup\n    ? randomEntities(random(0, 2), id)\n    : undefined;\n  if (random(0, 4) < 2) children = [];\n  return {\n    id,\n    name: `${random(0, 1) > 0 ? 'John Doe' : 'Jon Snow'} ${id}`,\n    type: isGroup ? 'group' : 'single',\n    children,\n    isGroup,\n  };\n};\n/** With increased chances of getting more groups */\nexport const randomEntitiesMoreGroups = (count) =>\n  new Array(count).fill(0).map(() => {\n    return randomEntityMoreGroup();\n  });\n","import React, { useState } from 'react';\nimport SearchBox from '@elliemae/ds-basic/form/SearchBox';\nimport DSToolbar from '@elliemae/ds-basic/Toolbar';\nimport DSSeparator from '@elliemae/ds-basic/Separator';\nimport DSButton from '@elliemae/ds-basic/Button';\n\nimport DSDropdownMenu from '@elliemae/ds-dropdownmenu';\nimport MoreOptionsVert from '@elliemae/ds-icons/MoreOptionsVert';\nimport { DSIconSizes } from '@elliemae/ds-basic/Icon';\n\nconst getOptions = (toggleExpandAll) => [\n  {\n    id: 'toggle-expand-collapse',\n    label: 'Expand All / Collapse All',\n    onClick: toggleExpandAll,\n  },\n];\nconst EllipsisMenu = ({ toggleExpandAll }) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const onOptionsClick = () => setIsOpen((isOpen) => !isOpen);\n  return (\n    <DSDropdownMenu\n      containerProps={{ id: 'tree-options-dropdown' }}\n      isOpen={isOpen}\n      onClickOutsideMenu={onOptionsClick}\n      options={getOptions(toggleExpandAll)}\n      triggerComponent={\n        <DSButton\n          buttonType=\"link\"\n          icon={<MoreOptionsVert size={DSIconSizes.M} />}\n          onClick={onOptionsClick}\n        />\n      }\n    />\n  );\n};\n\nexport const TreeToolbar = ({\n  searchQuery,\n  setSearchQuery,\n  toggleExpandAll,\n}) => {\n  return (\n    <>\n      <DSToolbar withDepth={false}>\n        <SearchBox\n          clearable\n          containerProps={{ 'data-testid': 'tree-searchbox' }}\n          onSearch={({ value }) => setSearchQuery(value)}\n          placeholder=\"Search all\"\n          searchOnEnter={false}\n          value={searchQuery}\n        />\n        <EllipsisMenu toggleExpandAll={toggleExpandAll} />\n      </DSToolbar>\n      <DSSeparator\n        margin=\"none\"\n        orientation=\"horizontal\"\n        type=\"non-form\"\n      />\n    </>\n  );\n};\n","import styled from 'styled-components';\n\n/** Fixes tree height issue */\nexport const TreeContainer = styled.div`\n  height: calc(100% - ${(props) => props.offsetHeight || 80}px);\n`;\n","import { useState } from 'react';\n\nexport const useTreeProps = () => {\n  const [disableGroups, setDisableGroups] = useState(false);\n  const toggleDisableGroups = () => setDisableGroups(!disableGroups);\n  return { disableGroups, toggleDisableGroups };\n};\n","import React, { useState, useRef, useEffect } from 'react';\nimport {\n  TreeView,\n  SelectablePluginTree,\n  SearchableTreePlugin,\n  // TreeDndPlugin,\n  // TreeToolbarPlugin\n} from '@elliemae/ds-treeview';\nimport Folder from '@elliemae/ds-icons/Folder';\nimport FilePdf from '@elliemae/ds-icons/FilePdf';\nimport DSCheckbox from '@elliemae/ds-basic/form/Checkbox';\nimport { TreeToolbar } from '../components/TreeToolbar';\nimport { TreeContainer } from '../components/TreeContainer';\nimport { randomEntitiesNoChildren } from '../utils/randomTreeNodes';\nimport { useTreeProps } from './customHooks/useTreeProps';\n// import { TooltipTextProvider } from \"@elliemae/ds-basic/TruncatedTooltipText\";\n// import renderToolbar from \"./renderToolbar\";\n\nconst nodes = randomEntitiesNoChildren(1000);\n\nconst onItemClick = (item) => {\n  console.log(111, item);\n};\n\nconst SingleSelect = () => {\n  const [searchQuery, setSearchQuery] = useState('');\n  const { disableGroups, toggleDisableGroups } = useTreeProps();\n\n  const ref = useRef(null);\n\n  const expandAll = () => {\n    const toggleExpandAll = ref.current.actions.toggleExpandAll;\n    console.log('REF', ref.current);\n    if (toggleExpandAll) toggleExpandAll();\n  };\n\n  useEffect(() => {\n    expandAll();\n  }, []);\n\n  return (\n    <TreeContainer>\n      <DSCheckbox\n        checked={disableGroups}\n        labelText=\"Disable Groups\"\n        onChange={toggleDisableGroups}\n      />\n      <TreeToolbar\n        searchQuery={searchQuery}\n        setSearchQuery={setSearchQuery}\n      />\n      <TreeView\n        data={nodes}\n        fluid\n        instanceRef={ref}\n        groupIcon={<Folder />}\n        isSingleSelect\n        itemIcon={<FilePdf />}\n        disableGroups={disableGroups}\n        // labelRenderer={value => value}\n        // onOrderChange={setData}\n        onItemClick={onItemClick}\n        plugins={[SelectablePluginTree, SearchableTreePlugin]}\n        // renderToolbar={renderToolbar}\n        searchQuery={searchQuery}\n        showChildrenAmount\n        // sortable\n        // width={400}\n      />\n    </TreeContainer>\n  );\n};\n\nexport default SingleSelect;\n","/* eslint-disable react/prop-types */\nimport React, { useMemo, useState } from 'react';\nimport DSPopover, { usePopoverProviderState } from '../Popover';\n\nexport const TruncatedTooltipContext = React.createContext();\n\nconst { Provider } = TruncatedTooltipContext;\n\nfunction TooltipTextProvider({\n  children,\n  tooltipDelay = 200,\n  placement = 'top',\n  ...tooltipOptions\n}) {\n  const {\n    show: showTooltip,\n    hide: hideTooltip,\n    state: tooltipState,\n  } = usePopoverProviderState({ delay: tooltipDelay });\n  const [zIndex, setZIndex] = useState(110);\n\n  const value = useMemo(\n    () => ({\n      showTooltip,\n      hideTooltip,\n      setZIndex,\n    }),\n    [],\n  );\n\n  return (\n    <Provider value={value}>\n      {children}\n      {tooltipState.visible ? (\n        <DSPopover\n          boundaries=\"window\"\n          placement={placement}\n          showArrow\n          {...tooltipOptions}\n          {...(tooltipState.options || {})}\n          content={tooltipState.value}\n          referenceEl={tooltipState.reference}\n          style={{ pointerEvents: 'none', zIndex }}\n          visible={tooltipState.visible}\n        />\n      ) : null}\n    </Provider>\n  );\n}\n\nTooltipTextProvider.propTypes = {};\nTooltipTextProvider.defaultProps = {};\n\nexport default TooltipTextProvider;\n","import React, { useContext, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport styled from 'styled-components';\nimport { PopperPositions as positions } from '../Popper';\nimport { TruncatedTooltipContext } from './TooltipTextProvider';\n\nconst isEllipsisActive = ({ offsetWidth, scrollWidth }) =>\n  offsetWidth < scrollWidth;\n\n// reduce the possibility of error showing the tooltip (text-overflow: ellipsis) https://jira.elliemae.io/browse/PUI-1755\nconst Text = styled.span`\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  display: inline-block;\n  max-width: 100%;\n`;\n\nfunction DSTruncatedTooltipText({\n  containerProps = {},\n  value = '',\n  zIndex = 110, // https://jira.elliemae.io/browse/PUI-1755\n  ...otherTextProps\n}) {\n  const tooltipContext = useContext(TruncatedTooltipContext);\n  useEffect(() => {\n    if (zIndex && tooltipContext) tooltipContext.setZIndex(zIndex);\n  }, [zIndex]);\n\n  if (!tooltipContext) return value;\n\n  const { showTooltip, hideTooltip } = tooltipContext;\n\n  const handleMouseEnter = (e) => {\n    const { target } = e;\n    if (target && isEllipsisActive(target, target.getBoundingClientRect())) {\n      showTooltip(\n        {\n          value,\n          reference: target,\n        },\n        e,\n      );\n    }\n  };\n\n  const handleMouseLeave = (e) => {\n    hideTooltip({ reference: e.target });\n  };\n\n  const handlers = showTooltip\n    ? { onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave }\n    : {};\n  return (\n    <Text {...containerProps} {...otherTextProps} {...handlers}>\n      {value}\n    </Text>\n  );\n}\n\nDSTruncatedTooltipText.propTypes = {\n  containerProps: PropTypes.shape({}),\n  /** Text that when truncated will trigger the tooltip interaction */\n  value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  /** Position of the tooltip */\n  tooltipPlacement: PropTypes.oneOf([\n    positions.AUTO_START,\n    positions.AUTO_END,\n    positions.AUTO,\n    positions.TOP_START,\n    positions.TOP,\n    positions.TOP_END,\n    positions.RIGHT_START,\n    positions.RIGHT,\n    positions.RIGHT_END,\n    positions.BOTTOM_START,\n    positions.BOTTOM,\n    positions.BOTTOM_END,\n    positions.LEFT_START,\n    positions.LEFT,\n    positions.LEFT_END,\n  ]),\n  /** Delay to show the tooltip */\n  tooltipDelay: PropTypes.number,\n  /** override default zIndex */\n  zIndex: PropTypes.number,\n};\n\nDSTruncatedTooltipText.defaultProps = {\n  containerProps: {},\n  value: '',\n  tooltipPlacement: undefined,\n  tooltipDelay: undefined,\n};\n\nexport default DSTruncatedTooltipText;\n","import { useRef, useState } from 'react';\nimport { isEqual, isFunction } from '../utils';\n\nconst defaultPropUpdateOnChange = prop => prop;\n\nfunction defaultShouldUpdate({ prop, prevProp, stateValue }) {\n  return !isEqual(prop, prevProp) && !isEqual(prop, stateValue);\n}\n\nfunction setStateWithUpdate(onUpdate, setState) {\n  return state => {\n    setState(prevState =>\n      onUpdate(isFunction(state) ? state(prevState) : state, prevState),\n    );\n  };\n}\n\nexport default function useDerivedStateFromProp(prop, options = {}) {\n  const {\n    onUpdate = defaultPropUpdateOnChange,\n    shouldUpdate = defaultShouldUpdate,\n    updateOnStateChange = false,\n  } = options;\n\n  const [stateValue, setState] = useState(onUpdate(prop, {}));\n  const handleSetState = updateOnStateChange\n    ? setStateWithUpdate(onUpdate, setState)\n    : setState;\n  const prevProp = useRef(prop);\n\n  if (\n    shouldUpdate({\n      prop,\n      prevProp: prevProp.current,\n      stateValue,\n    })\n  ) {\n    const nextProp = onUpdate(prop, prevProp.current);\n    setState(nextProp);\n  }\n  prevProp.current = prop;\n  return [stateValue, handleSetState];\n}\n","// @flow\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nconst hasNativePerformanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function';\n\nconst now = hasNativePerformanceNow\n  ? () => performance.now()\n  : () => Date.now();\n\nexport type TimeoutID = {|\n  id: AnimationFrameID,\n|};\n\nexport function cancelTimeout(timeoutID: TimeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nexport function requestTimeout(callback: Function, delay: number): TimeoutID {\n  const start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  const timeoutID: TimeoutID = {\n    id: requestAnimationFrame(tick),\n  };\n\n  return timeoutID;\n}\n","// @flow\n\nlet size: number = -1;\n\n// This utility copied from \"dom-helpers\" package.\nexport function getScrollbarSize(recalculate?: boolean = false): number {\n  if (size === -1 || recalculate) {\n    const div = document.createElement('div');\n    const style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n\n    ((document.body: any): HTMLBodyElement).appendChild(div);\n\n    size = div.offsetWidth - div.clientWidth;\n\n    ((document.body: any): HTMLBodyElement).removeChild(div);\n  }\n\n  return size;\n}\n\nexport type RTLOffsetType =\n  | 'negative'\n  | 'positive-descending'\n  | 'positive-ascending';\n\nlet cachedRTLResult: RTLOffsetType | null = null;\n\n// TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\nexport function getRTLOffsetType(recalculate?: boolean = false): RTLOffsetType {\n  if (cachedRTLResult === null || recalculate) {\n    const outerDiv = document.createElement('div');\n    const outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n\n    const innerDiv = document.createElement('div');\n    const innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n\n    outerDiv.appendChild(innerDiv);\n\n    ((document.body: any): HTMLBodyElement).appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    ((document.body: any): HTMLBodyElement).removeChild(outerDiv);\n\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getScrollbarSize, getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\ntype Direction = 'ltr' | 'rtl';\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n\ntype RenderComponentProps<T> = {|\n  columnIndex: number,\n  data: T,\n  isScrolling?: boolean,\n  rowIndex: number,\n  style: Object,\n|};\nexport type RenderComponent<T> = React$ComponentType<\n  $Shape<RenderComponentProps<T>>\n>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype OnItemsRenderedCallback = ({\n  overscanColumnStartIndex: number,\n  overscanColumnStopIndex: number,\n  overscanRowStartIndex: number,\n  overscanRowStopIndex: number,\n  visibleColumnStartIndex: number,\n  visibleColumnStopIndex: number,\n  visibleRowStartIndex: number,\n  visibleRowStopIndex: number,\n}) => void;\ntype OnScrollCallback = ({\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [key: string]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  columnCount: number,\n  columnWidth: itemSize,\n  direction: Direction,\n  height: number,\n  initialScrollLeft?: number,\n  initialScrollTop?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemData: T,\n  itemKey?: (params: {|\n    columnIndex: number,\n    data: T,\n    rowIndex: number,\n  |}) => any,\n  onItemsRendered?: OnItemsRenderedCallback,\n  onScroll?: OnScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanColumnCount?: number,\n  overscanColumnsCount?: number, // deprecated\n  overscanCount?: number, // deprecated\n  overscanRowCount?: number,\n  overscanRowsCount?: number, // deprecated\n  rowCount: number,\n  rowHeight: itemSize,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  horizontalScrollDirection: ScrollDirection,\n  scrollLeft: number,\n  scrollTop: number,\n  scrollUpdateWasRequested: boolean,\n  verticalScrollDirection: ScrollDirection,\n|};\n\ntype getItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype getEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForItemAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any,\n  scrollbarSize: number\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = ({ columnIndex, data, rowIndex }) =>\n  `${rowIndex}:${columnIndex}`;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsOverscanCount = null;\nlet devWarningsOverscanRowsColumnsCount = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = new WeakSet();\n    devWarningsOverscanRowsColumnsCount = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createGridComponent({\n  getColumnOffset,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getColumnWidth,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment,\n  getOffsetForRowAndAlignment,\n  getRowHeight,\n  getRowOffset,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getColumnOffset: getItemOffset,\n  getColumnStartIndexForOffset: GetStartIndexForOffset,\n  getColumnStopIndexForStartIndex: GetStopIndexForStartIndex,\n  getColumnWidth: getItemSize,\n  getEstimatedTotalHeight: getEstimatedTotalSize,\n  getEstimatedTotalWidth: getEstimatedTotalSize,\n  getOffsetForColumnAndAlignment: GetOffsetForItemAndAlignment,\n  getOffsetForRowAndAlignment: GetOffsetForItemAndAlignment,\n  getRowOffset: getItemOffset,\n  getRowHeight: getItemSize,\n  getRowStartIndexForOffset: GetStartIndexForOffset,\n  getRowStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class Grid<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n    _outerRef: ?HTMLDivElement;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      horizontalScrollDirection: 'forward',\n      scrollLeft:\n        typeof this.props.initialScrollLeft === 'number'\n          ? this.props.initialScrollLeft\n          : 0,\n      scrollTop:\n        typeof this.props.initialScrollTop === 'number'\n          ? this.props.initialScrollTop\n          : 0,\n      scrollUpdateWasRequested: false,\n      verticalScrollDirection: 'forward',\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo({\n      scrollLeft,\n      scrollTop,\n    }: {\n      scrollLeft: number,\n      scrollTop: number,\n    }): void {\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(prevState => {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem({\n      align = 'auto',\n      columnIndex,\n      rowIndex,\n    }: {\n      align: ScrollToAlign,\n      columnIndex?: number,\n      rowIndex?: number,\n    }): void {\n      const { columnCount, height, rowCount, width } = this.props;\n      const { scrollLeft, scrollTop } = this.state;\n      const scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n      const horizontalScrollbarSize =\n        estimatedTotalWidth > width ? scrollbarSize : 0;\n      const verticalScrollbarSize =\n        estimatedTotalHeight > height ? scrollbarSize : 0;\n\n      this.scrollTo({\n        scrollLeft:\n          columnIndex !== undefined\n            ? getOffsetForColumnAndAlignment(\n                this.props,\n                columnIndex,\n                align,\n                scrollLeft,\n                this._instanceProps,\n                verticalScrollbarSize\n              )\n            : scrollLeft,\n        scrollTop:\n          rowIndex !== undefined\n            ? getOffsetForRowAndAlignment(\n                this.props,\n                rowIndex,\n                align,\n                scrollTop,\n                this._instanceProps,\n                horizontalScrollbarSize\n              )\n            : scrollTop,\n      });\n    }\n\n    componentDidMount() {\n      const { initialScrollLeft, initialScrollTop } = this.props;\n\n      if (this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction } = this.props;\n      const { scrollLeft, scrollTop, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n            default:\n              const { clientWidth, scrollWidth } = outerRef;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        columnCount,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemData,\n        itemKey = defaultItemKey,\n        outerElementType,\n        outerTagName,\n        rowCount,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      const [\n        columnStartIndex,\n        columnStopIndex,\n      ] = this._getHorizontalRangeToRender();\n      const [rowStartIndex, rowStopIndex] = this._getVerticalRangeToRender();\n\n      const items = [];\n      if (columnCount > 0 && rowCount) {\n        for (\n          let rowIndex = rowStartIndex;\n          rowIndex <= rowStopIndex;\n          rowIndex++\n        ) {\n          for (\n            let columnIndex = columnStartIndex;\n            columnIndex <= columnStopIndex;\n            columnIndex++\n          ) {\n            items.push(\n              createElement(children, {\n                columnIndex,\n                data: itemData,\n                isScrolling: useIsScrolling ? isScrolling : undefined,\n                key: itemKey({ columnIndex, data: itemData, rowIndex }),\n                rowIndex,\n                style: this._getItemStyle(rowIndex, columnIndex),\n              })\n            );\n          }\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalHeight = getEstimatedTotalHeight(\n        this.props,\n        this._instanceProps\n      );\n      const estimatedTotalWidth = getEstimatedTotalWidth(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll: this._onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: estimatedTotalHeight,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: estimatedTotalWidth,\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanColumnStartIndex: number,\n      overscanColumnStopIndex: number,\n      overscanRowStartIndex: number,\n      overscanRowStopIndex: number,\n      visibleColumnStartIndex: number,\n      visibleColumnStopIndex: number,\n      visibleRowStartIndex: number,\n      visibleRowStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanColumnStartIndex: number,\n        overscanColumnStopIndex: number,\n        overscanRowStartIndex: number,\n        overscanRowStopIndex: number,\n        visibleColumnStartIndex: number,\n        visibleColumnStopIndex: number,\n        visibleRowStartIndex: number,\n        visibleRowStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): OnItemsRenderedCallback)({\n          overscanColumnStartIndex,\n          overscanColumnStopIndex,\n          overscanRowStartIndex,\n          overscanRowStopIndex,\n          visibleColumnStartIndex,\n          visibleColumnStopIndex,\n          visibleRowStartIndex,\n          visibleRowStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollLeft: number,\n      scrollTop: number,\n      horizontalScrollDirection: ScrollDirection,\n      verticalScrollDirection: ScrollDirection,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollLeft: number,\n        scrollTop: number,\n        horizontalScrollDirection: ScrollDirection,\n        verticalScrollDirection: ScrollDirection,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): OnScrollCallback)({\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          verticalScrollDirection,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      const { columnCount, onItemsRendered, onScroll, rowCount } = this.props;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          const [\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n          ] = this._getHorizontalRangeToRender();\n          const [\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex,\n          ] = this._getVerticalRangeToRender();\n          this._callOnItemsRendered(\n            overscanColumnStartIndex,\n            overscanColumnStopIndex,\n            overscanRowStartIndex,\n            overscanRowStopIndex,\n            visibleColumnStartIndex,\n            visibleColumnStopIndex,\n            visibleRowStartIndex,\n            visibleRowStopIndex\n          );\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        const {\n          horizontalScrollDirection,\n          scrollLeft,\n          scrollTop,\n          scrollUpdateWasRequested,\n          verticalScrollDirection,\n        } = this.state;\n        this._callOnScroll(\n          scrollLeft,\n          scrollTop,\n          horizontalScrollDirection,\n          verticalScrollDirection,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (rowIndex: number, columnIndex: number) => Object;\n    _getItemStyle = (rowIndex: number, columnIndex: number): Object => {\n      const { columnWidth, direction, rowHeight } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && columnWidth,\n        shouldResetStyleCacheOnItemSizeChange && direction,\n        shouldResetStyleCacheOnItemSizeChange && rowHeight\n      );\n\n      const key = `${rowIndex}:${columnIndex}`;\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(key)) {\n        style = itemStyleCache[key];\n      } else {\n        const offset = getColumnOffset(\n          this.props,\n          columnIndex,\n          this._instanceProps\n        );\n        const isRtl = direction === 'rtl';\n        itemStyleCache[key] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offset,\n          right: isRtl ? offset : undefined,\n          top: getRowOffset(this.props, rowIndex, this._instanceProps),\n          height: getRowHeight(this.props, rowIndex, this._instanceProps),\n          width: getColumnWidth(this.props, columnIndex, this._instanceProps),\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getHorizontalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanColumnCount,\n        overscanColumnsCount,\n        overscanCount,\n        rowCount,\n      } = this.props;\n      const { horizontalScrollDirection, isScrolling, scrollLeft } = this.state;\n\n      const overscanCountResolved: number =\n        overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getColumnStartIndexForOffset(\n        this.props,\n        scrollLeft,\n        this._instanceProps\n      );\n      const stopIndex = getColumnStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollLeft,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || horizontalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || horizontalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _getVerticalRangeToRender(): [number, number, number, number] {\n      const {\n        columnCount,\n        overscanCount,\n        overscanRowCount,\n        overscanRowsCount,\n        rowCount,\n      } = this.props;\n      const { isScrolling, verticalScrollDirection, scrollTop } = this.state;\n\n      const overscanCountResolved: number =\n        overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getRowStartIndexForOffset(\n        this.props,\n        scrollTop,\n        this._instanceProps\n      );\n      const stopIndex = getRowStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollTop,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || verticalScrollDirection === 'backward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n      const overscanForward =\n        !isScrolling || verticalScrollDirection === 'forward'\n          ? Math.max(1, overscanCountResolved)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScroll = (event: ScrollEvent): void => {\n      const {\n        clientHeight,\n        clientWidth,\n        scrollLeft,\n        scrollTop,\n        scrollHeight,\n        scrollWidth,\n      } = event.currentTarget;\n      this.setState(prevState => {\n        if (\n          prevState.scrollLeft === scrollLeft &&\n          prevState.scrollTop === scrollTop\n        ) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n        // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n        let calculatedScrollLeft = scrollLeft;\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              calculatedScrollLeft = -scrollLeft;\n              break;\n            case 'positive-descending':\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        calculatedScrollLeft = Math.max(\n          0,\n          Math.min(calculatedScrollLeft, scrollWidth - clientWidth)\n        );\n        const calculatedScrollTop = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          horizontalScrollDirection:\n            prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: calculatedScrollTop,\n          verticalScrollDirection:\n            prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1);\n      });\n    };\n  };\n}\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    innerTagName,\n    outerTagName,\n    overscanColumnsCount,\n    overscanCount,\n    overscanRowsCount,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn(\n          'The overscanCount prop has been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (\n      typeof overscanColumnsCount === 'number' ||\n      typeof overscanRowsCount === 'number'\n    ) {\n      if (\n        devWarningsOverscanRowsColumnsCount &&\n        !devWarningsOverscanRowsColumnsCount.has(instance)\n      ) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn(\n          'The overscanColumnsCount and overscanRowsCount props have been deprecated. ' +\n            'Please use the overscanColumnCount and overscanRowCount props instead.'\n        );\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    if (typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Grids must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    }\n\n    if (typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Grids must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport { cancelTimeout, requestTimeout } from './timer';\nimport { getRTLOffsetType } from './domHelpers';\n\nimport type { TimeoutID } from './timer';\n\nexport type ScrollToAlign = 'auto' | 'smart' | 'center' | 'start' | 'end';\n\ntype itemSize = number | ((index: number) => number);\n// TODO Deprecate directions \"horizontal\" and \"vertical\"\ntype Direction = 'ltr' | 'rtl' | 'horizontal' | 'vertical';\ntype Layout = 'horizontal' | 'vertical';\n\ntype RenderComponentProps<T> = {|\n  data: T,\n  index: number,\n  isScrolling?: boolean,\n  style: Object,\n|};\ntype RenderComponent<T> = React$ComponentType<$Shape<RenderComponentProps<T>>>;\n\ntype ScrollDirection = 'forward' | 'backward';\n\ntype onItemsRenderedCallback = ({\n  overscanStartIndex: number,\n  overscanStopIndex: number,\n  visibleStartIndex: number,\n  visibleStopIndex: number,\n}) => void;\ntype onScrollCallback = ({\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n}) => void;\n\ntype ScrollEvent = SyntheticEvent<HTMLDivElement>;\ntype ItemStyleCache = { [index: number]: Object };\n\ntype OuterProps = {|\n  children: React$Node,\n  className: string | void,\n  onScroll: ScrollEvent => void,\n  style: {\n    [string]: mixed,\n  },\n|};\n\ntype InnerProps = {|\n  children: React$Node,\n  style: {\n    [string]: mixed,\n  },\n|};\n\nexport type Props<T> = {|\n  children: RenderComponent<T>,\n  className?: string,\n  direction: Direction,\n  height: number | string,\n  initialScrollOffset?: number,\n  innerRef?: any,\n  innerElementType?: string | React$AbstractComponent<InnerProps, any>,\n  innerTagName?: string, // deprecated\n  itemCount: number,\n  itemData: T,\n  itemKey?: (index: number, data: T) => any,\n  itemSize: itemSize,\n  layout: Layout,\n  onItemsRendered?: onItemsRenderedCallback,\n  onScroll?: onScrollCallback,\n  outerRef?: any,\n  outerElementType?: string | React$AbstractComponent<OuterProps, any>,\n  outerTagName?: string, // deprecated\n  overscanCount: number,\n  style?: Object,\n  useIsScrolling: boolean,\n  width: number | string,\n|};\n\ntype State = {|\n  instance: any,\n  isScrolling: boolean,\n  scrollDirection: ScrollDirection,\n  scrollOffset: number,\n  scrollUpdateWasRequested: boolean,\n|};\n\ntype GetItemOffset = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetItemSize = (\n  props: Props<any>,\n  index: number,\n  instanceProps: any\n) => number;\ntype GetEstimatedTotalSize = (props: Props<any>, instanceProps: any) => number;\ntype GetOffsetForIndexAndAlignment = (\n  props: Props<any>,\n  index: number,\n  align: ScrollToAlign,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype GetStartIndexForOffset = (\n  props: Props<any>,\n  offset: number,\n  instanceProps: any\n) => number;\ntype GetStopIndexForStartIndex = (\n  props: Props<any>,\n  startIndex: number,\n  scrollOffset: number,\n  instanceProps: any\n) => number;\ntype InitInstanceProps = (props: Props<any>, instance: any) => any;\ntype ValidateProps = (props: Props<any>) => void;\n\nconst IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nconst defaultItemKey = (index: number, data: any) => index;\n\n// In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\nlet devWarningsDirection = null;\nlet devWarningsTagName = null;\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = new WeakSet();\n    devWarningsTagName = new WeakSet();\n  }\n}\n\nexport default function createListComponent({\n  getItemOffset,\n  getEstimatedTotalSize,\n  getItemSize,\n  getOffsetForIndexAndAlignment,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange,\n  validateProps,\n}: {|\n  getItemOffset: GetItemOffset,\n  getEstimatedTotalSize: GetEstimatedTotalSize,\n  getItemSize: GetItemSize,\n  getOffsetForIndexAndAlignment: GetOffsetForIndexAndAlignment,\n  getStartIndexForOffset: GetStartIndexForOffset,\n  getStopIndexForStartIndex: GetStopIndexForStartIndex,\n  initInstanceProps: InitInstanceProps,\n  shouldResetStyleCacheOnItemSizeChange: boolean,\n  validateProps: ValidateProps,\n|}) {\n  return class List<T> extends PureComponent<Props<T>, State> {\n    _instanceProps: any = initInstanceProps(this.props, this);\n    _outerRef: ?HTMLDivElement;\n    _resetIsScrollingTimeoutId: TimeoutID | null = null;\n\n    static defaultProps = {\n      direction: 'ltr',\n      itemData: undefined,\n      layout: 'vertical',\n      overscanCount: 2,\n      useIsScrolling: false,\n    };\n\n    state: State = {\n      instance: this,\n      isScrolling: false,\n      scrollDirection: 'forward',\n      scrollOffset:\n        typeof this.props.initialScrollOffset === 'number'\n          ? this.props.initialScrollOffset\n          : 0,\n      scrollUpdateWasRequested: false,\n    };\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    constructor(props: Props<T>) {\n      super(props);\n    }\n\n    static getDerivedStateFromProps(\n      nextProps: Props<T>,\n      prevState: State\n    ): $Shape<State> | null {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    }\n\n    scrollTo(scrollOffset: number): void {\n      scrollOffset = Math.max(0, scrollOffset);\n\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n        return {\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true,\n        };\n      }, this._resetIsScrollingDebounced);\n    }\n\n    scrollToItem(index: number, align: ScrollToAlign = 'auto'): void {\n      const { itemCount } = this.props;\n      const { scrollOffset } = this.state;\n\n      index = Math.max(0, Math.min(index, itemCount - 1));\n\n      this.scrollTo(\n        getOffsetForIndexAndAlignment(\n          this.props,\n          index,\n          align,\n          scrollOffset,\n          this._instanceProps\n        )\n      );\n    }\n\n    componentDidMount() {\n      const { direction, initialScrollOffset, layout } = this.props;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentDidUpdate() {\n      const { direction, layout } = this.props;\n      const { scrollOffset, scrollUpdateWasRequested } = this.state;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        const outerRef = ((this._outerRef: any): HTMLElement);\n\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n              default:\n                const { clientWidth, scrollWidth } = outerRef;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    }\n\n    componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    }\n\n    render() {\n      const {\n        children,\n        className,\n        direction,\n        height,\n        innerRef,\n        innerElementType,\n        innerTagName,\n        itemCount,\n        itemData,\n        itemKey = defaultItemKey,\n        layout,\n        outerElementType,\n        outerTagName,\n        style,\n        useIsScrolling,\n        width,\n      } = this.props;\n      const { isScrolling } = this.state;\n\n      // TODO Deprecate direction \"horizontal\"\n      const isHorizontal =\n        direction === 'horizontal' || layout === 'horizontal';\n\n      const onScroll = isHorizontal\n        ? this._onScrollHorizontal\n        : this._onScrollVertical;\n\n      const [startIndex, stopIndex] = this._getRangeToRender();\n\n      const items = [];\n      if (itemCount > 0) {\n        for (let index = startIndex; index <= stopIndex; index++) {\n          items.push(\n            createElement(children, {\n              data: itemData,\n              key: itemKey(index, itemData),\n              index,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              style: this._getItemStyle(index),\n            })\n          );\n        }\n      }\n\n      // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n      const estimatedTotalSize = getEstimatedTotalSize(\n        this.props,\n        this._instanceProps\n      );\n\n      return createElement(\n        outerElementType || outerTagName || 'div',\n        {\n          className,\n          onScroll,\n          ref: this._outerRefSetter,\n          style: {\n            position: 'relative',\n            height,\n            width,\n            overflow: 'auto',\n            WebkitOverflowScrolling: 'touch',\n            willChange: 'transform',\n            direction,\n            ...style,\n          },\n        },\n        createElement(innerElementType || innerTagName || 'div', {\n          children: items,\n          ref: innerRef,\n          style: {\n            height: isHorizontal ? '100%' : estimatedTotalSize,\n            pointerEvents: isScrolling ? 'none' : undefined,\n            width: isHorizontal ? estimatedTotalSize : '100%',\n          },\n        })\n      );\n    }\n\n    _callOnItemsRendered: (\n      overscanStartIndex: number,\n      overscanStopIndex: number,\n      visibleStartIndex: number,\n      visibleStopIndex: number\n    ) => void;\n    _callOnItemsRendered = memoizeOne(\n      (\n        overscanStartIndex: number,\n        overscanStopIndex: number,\n        visibleStartIndex: number,\n        visibleStopIndex: number\n      ) =>\n        ((this.props.onItemsRendered: any): onItemsRenderedCallback)({\n          overscanStartIndex,\n          overscanStopIndex,\n          visibleStartIndex,\n          visibleStopIndex,\n        })\n    );\n\n    _callOnScroll: (\n      scrollDirection: ScrollDirection,\n      scrollOffset: number,\n      scrollUpdateWasRequested: boolean\n    ) => void;\n    _callOnScroll = memoizeOne(\n      (\n        scrollDirection: ScrollDirection,\n        scrollOffset: number,\n        scrollUpdateWasRequested: boolean\n      ) =>\n        ((this.props.onScroll: any): onScrollCallback)({\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        })\n    );\n\n    _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        const { itemCount } = this.props;\n        if (itemCount > 0) {\n          const [\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex,\n          ] = this._getRangeToRender();\n          this._callOnItemsRendered(\n            overscanStartIndex,\n            overscanStopIndex,\n            visibleStartIndex,\n            visibleStopIndex\n          );\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        const {\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested,\n        } = this.state;\n        this._callOnScroll(\n          scrollDirection,\n          scrollOffset,\n          scrollUpdateWasRequested\n        );\n      }\n    }\n\n    // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    _getItemStyle: (index: number) => Object;\n    _getItemStyle = (index: number): Object => {\n      const { direction, itemSize, layout } = this.props;\n\n      const itemStyleCache = this._getItemStyleCache(\n        shouldResetStyleCacheOnItemSizeChange && itemSize,\n        shouldResetStyleCacheOnItemSizeChange && layout,\n        shouldResetStyleCacheOnItemSizeChange && direction\n      );\n\n      let style;\n      if (itemStyleCache.hasOwnProperty(index)) {\n        style = itemStyleCache[index];\n      } else {\n        const offset = getItemOffset(this.props, index, this._instanceProps);\n        const size = getItemSize(this.props, index, this._instanceProps);\n\n        // TODO Deprecate direction \"horizontal\"\n        const isHorizontal =\n          direction === 'horizontal' || layout === 'horizontal';\n\n        const isRtl = direction === 'rtl';\n        const offsetHorizontal = isHorizontal ? offset : 0;\n        itemStyleCache[index] = style = {\n          position: 'absolute',\n          left: isRtl ? undefined : offsetHorizontal,\n          right: isRtl ? offsetHorizontal : undefined,\n          top: !isHorizontal ? offset : 0,\n          height: !isHorizontal ? size : '100%',\n          width: isHorizontal ? size : '100%',\n        };\n      }\n\n      return style;\n    };\n\n    _getItemStyleCache: (_: any, __: any, ___: any) => ItemStyleCache;\n    _getItemStyleCache = memoizeOne((_: any, __: any, ___: any) => ({}));\n\n    _getRangeToRender(): [number, number, number, number] {\n      const { itemCount, overscanCount } = this.props;\n      const { isScrolling, scrollDirection, scrollOffset } = this.state;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      const startIndex = getStartIndexForOffset(\n        this.props,\n        scrollOffset,\n        this._instanceProps\n      );\n      const stopIndex = getStopIndexForStartIndex(\n        this.props,\n        startIndex,\n        scrollOffset,\n        this._instanceProps\n      );\n\n      // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n      const overscanBackward =\n        !isScrolling || scrollDirection === 'backward'\n          ? Math.max(1, overscanCount)\n          : 1;\n      const overscanForward =\n        !isScrolling || scrollDirection === 'forward'\n          ? Math.max(1, overscanCount)\n          : 1;\n\n      return [\n        Math.max(0, startIndex - overscanBackward),\n        Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)),\n        startIndex,\n        stopIndex,\n      ];\n    }\n\n    _onScrollHorizontal = (event: ScrollEvent): void => {\n      const { clientWidth, scrollLeft, scrollWidth } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollLeft) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        const { direction } = this.props;\n\n        let scrollOffset = scrollLeft;\n        if (direction === 'rtl') {\n          // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              scrollOffset = -scrollLeft;\n              break;\n            case 'positive-descending':\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        scrollOffset = Math.max(\n          0,\n          Math.min(scrollOffset, scrollWidth - clientWidth)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _onScrollVertical = (event: ScrollEvent): void => {\n      const { clientHeight, scrollHeight, scrollTop } = event.currentTarget;\n      this.setState(prevState => {\n        if (prevState.scrollOffset === scrollTop) {\n          // Scroll position may have been updated by cDM/cDU,\n          // In which case we don't need to trigger another render,\n          // And we don't want to update state.isScrolling.\n          return null;\n        }\n\n        // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n        const scrollOffset = Math.max(\n          0,\n          Math.min(scrollTop, scrollHeight - clientHeight)\n        );\n\n        return {\n          isScrolling: true,\n          scrollDirection:\n            prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset,\n          scrollUpdateWasRequested: false,\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _outerRefSetter = (ref: any): void => {\n      const { outerRef } = this.props;\n\n      this._outerRef = ((ref: any): HTMLDivElement);\n\n      if (typeof outerRef === 'function') {\n        outerRef(ref);\n      } else if (\n        outerRef != null &&\n        typeof outerRef === 'object' &&\n        outerRef.hasOwnProperty('current')\n      ) {\n        outerRef.current = ref;\n      }\n    };\n\n    _resetIsScrollingDebounced = () => {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._resetIsScrollingTimeoutId = requestTimeout(\n        this._resetIsScrolling,\n        IS_SCROLLING_DEBOUNCE_INTERVAL\n      );\n    };\n\n    _resetIsScrolling = () => {\n      this._resetIsScrollingTimeoutId = null;\n\n      this.setState({ isScrolling: false }, () => {\n        // Clear style cache after state update has been committed.\n        // This way we don't break pure sCU for items that don't use isScrolling param.\n        this._getItemStyleCache(-1, null);\n      });\n    };\n  };\n}\n\n// NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nconst validateSharedProps = (\n  {\n    children,\n    direction,\n    height,\n    layout,\n    innerTagName,\n    outerTagName,\n    width,\n  }: Props<any>,\n  { instance }: State\n): void => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn(\n          'The innerTagName and outerTagName props have been deprecated. ' +\n            'Please use the innerElementType and outerElementType props instead.'\n        );\n      }\n    }\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn(\n            'The direction prop should be either \"ltr\" (default) or \"rtl\". ' +\n              'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.'\n          );\n        }\n        break;\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"direction\" prop has been specified. ' +\n            'Value should be either \"ltr\" or \"rtl\". ' +\n            `\"${direction}\" was specified.`\n        );\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n      default:\n        throw Error(\n          'An invalid \"layout\" prop has been specified. ' +\n            'Value should be either \"horizontal\" or \"vertical\". ' +\n            `\"${layout}\" was specified.`\n        );\n    }\n\n    if (children == null) {\n      throw Error(\n        'An invalid \"children\" prop has been specified. ' +\n          'Value should be a React component. ' +\n          `\"${children === null ? 'null' : typeof children}\" was specified.`\n      );\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error(\n        'An invalid \"width\" prop has been specified. ' +\n          'Horizontal lists must specify a number for width. ' +\n          `\"${width === null ? 'null' : typeof width}\" was specified.`\n      );\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error(\n        'An invalid \"height\" prop has been specified. ' +\n          'Vertical lists must specify a number for height. ' +\n          `\"${height === null ? 'null' : typeof height}\" was specified.`\n      );\n    }\n  }\n};\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\ntype VariableSizeProps = {|\n  estimatedItemSize: number,\n  ...Props<any>,\n|};\n\ntype itemSizeGetter = (index: number) => number;\n\ntype ItemMetadata = {|\n  offset: number,\n  size: number,\n|};\ntype InstanceProps = {|\n  itemMetadataMap: { [index: number]: ItemMetadata },\n  estimatedItemSize: number,\n  lastMeasuredIndex: number,\n|};\n\nconst getItemMetadata = (\n  props: Props<any>,\n  index: number,\n  instanceProps: InstanceProps\n): ItemMetadata => {\n  const { itemSize } = ((props: any): VariableSizeProps);\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  if (index > lastMeasuredIndex) {\n    let offset = 0;\n    if (lastMeasuredIndex >= 0) {\n      const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (let i = lastMeasuredIndex + 1; i <= index; i++) {\n      let size = ((itemSize: any): itemSizeGetter)(i);\n\n      itemMetadataMap[i] = {\n        offset,\n        size,\n      };\n\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nconst findNearestItem = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  offset: number\n) => {\n  const { itemMetadataMap, lastMeasuredIndex } = instanceProps;\n\n  const lastMeasuredItemOffset =\n    lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(\n      props,\n      instanceProps,\n      lastMeasuredIndex,\n      0,\n      offset\n    );\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(\n      props,\n      instanceProps,\n      Math.max(0, lastMeasuredIndex),\n      offset\n    );\n  }\n};\n\nconst findNearestItemBinarySearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  high: number,\n  low: number,\n  offset: number\n): number => {\n  while (low <= high) {\n    const middle = low + Math.floor((high - low) / 2);\n    const currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nconst findNearestItemExponentialSearch = (\n  props: Props<any>,\n  instanceProps: InstanceProps,\n  index: number,\n  offset: number\n): number => {\n  const { itemCount } = props;\n  let interval = 1;\n\n  while (\n    index < itemCount &&\n    getItemMetadata(props, index, instanceProps).offset < offset\n  ) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(\n    props,\n    instanceProps,\n    Math.min(index, itemCount - 1),\n    Math.floor(index / 2),\n    offset\n  );\n};\n\nconst getEstimatedTotalSize = (\n  { itemCount }: Props<any>,\n  { itemMetadataMap, estimatedItemSize, lastMeasuredIndex }: InstanceProps\n) => {\n  let totalSizeOfMeasuredItems = 0;\n\n  // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    const itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  const numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  const totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nconst VariableSizeList = createListComponent({\n  getItemOffset: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => getItemMetadata(props, index, instanceProps).offset,\n\n  getItemSize: (\n    props: Props<any>,\n    index: number,\n    instanceProps: InstanceProps\n  ): number => instanceProps.itemMetadataMap[index].size,\n\n  getEstimatedTotalSize,\n\n  getOffsetForIndexAndAlignment: (\n    props: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, index, instanceProps);\n\n    // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n    const estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n\n    const maxOffset = Math.max(\n      0,\n      Math.min(estimatedTotalSize - size, itemMetadata.offset)\n    );\n    const minOffset = Math.max(\n      0,\n      itemMetadata.offset - size + itemMetadata.size\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    props: Props<any>,\n    offset: number,\n    instanceProps: InstanceProps\n  ): number => findNearestItem(props, instanceProps, offset),\n\n  getStopIndexForStartIndex: (\n    props: Props<any>,\n    startIndex: number,\n    scrollOffset: number,\n    instanceProps: InstanceProps\n  ): number => {\n    const { direction, height, itemCount, layout, width } = props;\n\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    const maxOffset = scrollOffset + size;\n\n    let offset = itemMetadata.offset + itemMetadata.size;\n    let stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n\n  initInstanceProps(props: Props<any>, instance: any): InstanceProps {\n    const { estimatedItemSize } = ((props: any): VariableSizeProps);\n\n    const instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredIndex: -1,\n    };\n\n    instance.resetAfterIndex = (\n      index: number,\n      shouldForceUpdate?: boolean = true\n    ) => {\n      instanceProps.lastMeasuredIndex = Math.min(\n        instanceProps.lastMeasuredIndex,\n        index - 1\n      );\n\n      // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: false,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a function. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default VariableSizeList;\n","// @flow\n\nimport createListComponent from './createListComponent';\n\nimport type { Props, ScrollToAlign } from './createListComponent';\n\nconst FixedSizeList = createListComponent({\n  getItemOffset: ({ itemSize }: Props<any>, index: number): number =>\n    index * ((itemSize: any): number),\n\n  getItemSize: ({ itemSize }: Props<any>, index: number): number =>\n    ((itemSize: any): number),\n\n  getEstimatedTotalSize: ({ itemCount, itemSize }: Props<any>) =>\n    ((itemSize: any): number) * itemCount,\n\n  getOffsetForIndexAndAlignment: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    index: number,\n    align: ScrollToAlign,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const size = (((isHorizontal ? width : height): any): number);\n    const lastItemOffset = Math.max(\n      0,\n      itemCount * ((itemSize: any): number) - size\n    );\n    const maxOffset = Math.min(\n      lastItemOffset,\n      index * ((itemSize: any): number)\n    );\n    const minOffset = Math.max(\n      0,\n      index * ((itemSize: any): number) - size + ((itemSize: any): number)\n    );\n\n    if (align === 'smart') {\n      if (\n        scrollOffset >= minOffset - size &&\n        scrollOffset <= maxOffset + size\n      ) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n      case 'end':\n        return minOffset;\n      case 'center': {\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        const middleOffset = Math.round(\n          minOffset + (maxOffset - minOffset) / 2\n        );\n        if (middleOffset < Math.ceil(size / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n          return lastItemOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n      }\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n    }\n  },\n\n  getStartIndexForOffset: (\n    { itemCount, itemSize }: Props<any>,\n    offset: number\n  ): number =>\n    Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(offset / ((itemSize: any): number)))\n    ),\n\n  getStopIndexForStartIndex: (\n    { direction, height, itemCount, itemSize, layout, width }: Props<any>,\n    startIndex: number,\n    scrollOffset: number\n  ): number => {\n    // TODO Deprecate direction \"horizontal\"\n    const isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    const offset = startIndex * ((itemSize: any): number);\n    const size = (((isHorizontal ? width : height): any): number);\n    const numVisibleItems = Math.ceil(\n      (size + scrollOffset - offset) / ((itemSize: any): number)\n    );\n    return Math.max(\n      0,\n      Math.min(\n        itemCount - 1,\n        startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n      )\n    );\n  },\n\n  initInstanceProps(props: Props<any>): any {\n    // Noop\n  },\n\n  shouldResetStyleCacheOnItemSizeChange: true,\n\n  validateProps: ({ itemSize }: Props<any>): void => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error(\n          'An invalid \"itemSize\" prop has been specified. ' +\n            'Value should be a number. ' +\n            `\"${itemSize === null ? 'null' : typeof itemSize}\" was specified.`\n        );\n      }\n    }\n  },\n});\n\nexport default FixedSizeList;\n","// @flow\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nexport default function shallowDiffers(prev: Object, next: Object): boolean {\n  for (let attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n  for (let attribute in next) {\n    if (prev[attribute] !== next[attribute]) {\n      return true;\n    }\n  }\n  return false;\n}\n","// @flow\n\nimport shallowDiffers from './shallowDiffers';\n\n// Custom comparison function for React.memo().\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\nexport default function areEqual(\n  prevProps: Object,\n  nextProps: Object\n): boolean {\n  const { style: prevStyle, ...prevRest } = prevProps;\n  const { style: nextStyle, ...nextRest } = nextProps;\n\n  return (\n    !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest)\n  );\n}\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport DSInput from '../Input';\n\nconst DSTextBox = ({\n  containerProps = {},\n  autoFocus = false,\n  disabled = false,\n  maxLength = 255,\n  minLength = 0,\n  fluidWidth = false,\n  placeholder,\n  value = '',\n  hasError = false,\n  readOnly = false,\n  innerRef = null,\n  type = 'text',\n  min = undefined,\n  max = undefined,\n  clearable = false,\n  leftComponent = null,\n  rightComponent = null,\n  required = false,\n  variant,\n  ...otherProps\n}) => (\n  <DSInput\n    {...otherProps}\n    aria-label={otherProps['aria-label'] || 'Text Box'}\n    autoFocus={autoFocus}\n    clearable={clearable}\n    containerProps={containerProps}\n    disabled={disabled}\n    fluidWidth={fluidWidth}\n    hasError={hasError}\n    innerRef={innerRef}\n    leftComponent={leftComponent}\n    max={max}\n    maxLength={maxLength}\n    min={min}\n    minLength={minLength}\n    placeholder={placeholder}\n    readOnly={readOnly}\n    required={required}\n    rightComponent={rightComponent}\n    role=\"textbox\"\n    type={type}\n    value={value}\n    variant={variant}\n  />\n);\n\nDSTextBox.propTypes = {\n  containerProps: PropTypes.shape({}),\n  /**\n   * Whether the text box uses auto focus or not\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * Whether the text box is disabled or not\n   */\n  disabled: PropTypes.bool,\n  /**\n   * Max length for the text box\n   */\n  maxLength: PropTypes.number,\n  /**\n   * Min length for the text box\n   */\n  minLength: PropTypes.number,\n  /**\n   * Make the content of the text box fit the container or not\n   */\n  fluidWidth: PropTypes.bool,\n  /**\n   * Placeholder for the text box\n   */\n  placeholder: PropTypes.string,\n  /**\n   * Default value once the component is initialized\n   */\n  value: PropTypes.string,\n  /**\n   * Whether the text box has error or not\n   */\n  hasError: PropTypes.bool,\n  /**\n   * Whether the text box is read only or not\n   */\n  readOnly: PropTypes.bool,\n  min: PropTypes.number,\n  max: PropTypes.number,\n  /**\n   * Whether the text box is clearable or not\n   */\n  clearable: PropTypes.bool,\n  /**\n   * Component to be added at the left side of the text box\n   */\n  leftComponent: PropTypes.element,\n  /**\n   * Component to be added at the right side of the text box\n   */\n  rightComponent: PropTypes.element,\n  /**\n   * Whether the text box is required or not\n   */\n  required: PropTypes.bool,\n  /**\n   * [\n   *  'variant-default',\n   *  'variant-focus',\n   *  'variant-active',\n   *  'variant-disabled',\n   * ]\n   */\n  variant: PropTypes.string,\n};\n\nexport default DSTextBox;\n","import { useContext, useEffect } from 'react';\nimport FocusGroupContext from './FocusGroupContext';\n\nexport default function useFocusGroupItem(ref = {}, props) {\n  const { register, unregister, ...otherActions } =\n    useContext(FocusGroupContext) || {};\n\n  useEffect(() => {\n    if (ref.current && register) register(ref.current, props);\n    return () => {\n      if (ref.current && unregister) unregister(ref.current);\n    };\n  });\n\n  // if the focus item is not wrapped with the focus provider then return null\n  if (!register) return {};\n  return otherActions;\n}\n\nexport const useFocusGroupWithState = (ref = {}, props) => {\n  const { register, unregister, ...otherActions } =\n    useContext(FocusGroupContext) || {};\n\n  useEffect(() => {\n    if (ref && register) register(ref, props);\n    return () => {\n      if (ref && unregister) unregister(ref);\n    };\n  }, [ref]);\n\n  // if the focus item is not wrapped with the focus provider then return null\n  if (!register) return {};\n  return otherActions;\n};\n","/* eslint-disable */\nimport createIcon from './utils/createIcon';\n\nexport default createIcon({\n  paths: [\n    'M9.496 12c-.828 0-1.5-.672-1.5-1.5S8.668 9 9.496 9s1.5.672 1.5 1.5-.672 1.5-1.5 1.5zM9.496 7c-.828 0-1.5-.672-1.5-1.5S8.668 4 9.496 4s1.5.672 1.5 1.5-.672 1.5-1.5 1.5zM9.496 17c-.828 0-1.5-.672-1.5-1.5s.672-1.5 1.5-1.5 1.5.672 1.5 1.5-.672 1.5-1.5 1.5z',\n  ],\n  height: 20,\n  width: 20,\n});\n","/* eslint-disable */\nimport createIcon from './utils/createIcon';\n\nexport default createIcon({\n  paths: [\n    'M18.869 19.162l-5.943-6.484c1.339-1.401 2.075-3.233 2.075-5.178 0-2.003-.78-3.887-2.197-5.303S9.504 0 7.501 0 3.614.78 2.198 2.197.001 5.497.001 7.5s.78 3.887 2.197 5.303S5.498 15 7.501 15c1.726 0 3.362-.579 4.688-1.645l5.943 6.483a.497.497 0 0 0 .369.162.4997.4997 0 0 0 .369-.837l-.001-.001zM1 7.5C1 3.916 3.916 1 7.5 1S14 3.916 14 7.5 11.084 14 7.5 14 1 11.084 1 7.5z',\n  ],\n  height: 20,\n  width: 20,\n});\n","import React, { cloneElement, useCallback, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { addOrRemove, runAll } from '@elliemae/ds-utilities/utils';\nimport useDerivedStateFromProps from '@elliemae/ds-utilities/hooks/useDerivedStateFromProps';\n\nexport function useCheckableGroup({\n  children,\n  active: activeProp,\n  multi,\n  onCheck = () => null,\n}) {\n  const [active, setActive] = useDerivedStateFromProps(activeProp);\n\n  const handleCheck = ({ target: { value } }, item) => {\n    setActive(prevActive => {\n      const nextActive = multi ? addOrRemove(prevActive, value) : value;\n      onCheck(nextActive, item);\n      return nextActive;\n    });\n  };\n\n  return React.Children.map(children, child => {\n    const { props } = child;\n    const checked = Array.isArray(active)\n      ? active.indexOf(props.name) !== -1\n      : active === props.name;\n\n    return cloneElement(child, {\n      ...props,\n      checked,\n      onClick: runAll(handleCheck, props.onClick),\n    });\n  });\n}\n\nfunction CheckableGroup({\n  active = [],\n  multi = false, // checkbox or radio\n  children,\n}) {\n  return useCheckableGroup({ active, multi, children });\n}\n\nCheckableGroup.propTypes = {\n  /* The item (if multi false) or items (if multi true) selected */\n  active: PropTypes.arrayOf(PropTypes.string),\n  /* Whether is multi select or not */\n  multi: PropTypes.bool,\n  /* Handler when a user checks an item */\n  onCheck: PropTypes.func,\n};\n\nexport default CheckableGroup;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { debounce } from '@elliemae/ds-utilities/utils';\n\nconst withSearchable = (WrappedComponent) => {\n  class Searchable extends Component {\n    debouncedSearch = debounce(this.handleSearch, 200);\n\n    constructor(props) {\n      super(props);\n      this.state = {\n        value: props.value,\n      };\n      this.handleSearch = this.handleSearch.bind(this);\n      this.handleKeyUp = this.handleKeyUp.bind(this);\n      this.handleChange = this.handleChange.bind(this);\n      this.buttonRef = React.createRef();\n    }\n\n    static getDerivedStateFromProps(nextProps, { prevPropValue }) {\n      if (nextProps.value !== prevPropValue) {\n        return {\n          value: nextProps.value,\n          prevPropValue: nextProps.value,\n        };\n      }\n      return null;\n    }\n\n    handleKeyUp(e) {\n      const { onKeyUp, searchOnEnter } = this.props;\n      const { key } = e;\n      if (searchOnEnter && key === 'Enter') {\n        this.handleSearch();\n      }\n      onKeyUp(e);\n    }\n\n    handleSearch() {\n      const { onSearch, property, clearOnSearch, searchOnEnter } = this.props;\n      const { value } = this.state;\n\n      if (clearOnSearch) this.setState({ value: '' });\n      if (searchOnEnter && !value) return;\n      onSearch({\n        query: { [property]: value },\n        property,\n        value,\n      });\n    }\n\n    handleChange({ target }) {\n      const { value } = target;\n      const { searchOnEnter, onChange } = this.props;\n      onChange(value);\n      this.setState({ value }, () => {\n        if (!searchOnEnter) this.debouncedSearch();\n      });\n    }\n\n    render() {\n      const { value } = this.state;\n      const { containerProps, ...rest } = this.props;\n\n      return (\n        <WrappedComponent\n          {...rest}\n          buttonRef={this.buttonRef}\n          containerProps={containerProps}\n          onChange={this.handleChange}\n          onKeyUp={this.handleKeyUp}\n          onSearch={this.handleSearch}\n          value={value}\n        />\n      );\n    }\n  }\n\n  Searchable.defaultProps = {\n    onChange: () => null,\n    onSearch: () => null,\n    onKeyUp: () => null,\n    property: 'all',\n    searchOnEnter: true,\n    clearOnSearch: false,\n    containerProps: {},\n  };\n\n  Searchable.propTypes = {\n    containerProps: PropTypes.shape({}),\n    onChange: PropTypes.func,\n    onSearch: PropTypes.func,\n    onKeyUp: PropTypes.func,\n    property: PropTypes.string,\n    searchOnEnter: PropTypes.bool,\n    clearOnSearch: PropTypes.bool,\n    value: PropTypes.string,\n  };\n\n  return Searchable;\n};\n\nexport default withSearchable;\n","/* eslint-disable react/no-unused-state */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Search from '@elliemae/ds-icons/Search';\nimport DSButton from '../../Button';\nimport DSTextBox from '../TextBox';\nimport withSearchable from './withSearchable';\n\nconst SearchBoxImpl = ({\n  containerProps,\n  placeholder,\n  className,\n  disabled,\n  disableButton,\n  innerRef,\n  showIcon,\n  style,\n  onChange,\n  onKeyUp,\n  onSearch,\n  onBlur,\n  readOnly,\n  value,\n  clearable,\n}) => (\n  <DSTextBox\n    className={className}\n    clearable={clearable}\n    containerProps={containerProps}\n    disabled={disabled}\n    innerRef={innerRef}\n    onChange={onChange}\n    onKeyUp={onKeyUp}\n    onBlur={onBlur}\n    placeholder={placeholder}\n    readOnly={readOnly}\n    rightComponent={\n      showIcon && (\n        <DSButton\n          disabled={disabled || disableButton}\n          buttonType=\"text\"\n          icon={<Search />}\n          iconSize=\"s\"\n          onClick={onSearch}\n          type=\"secondary\"\n          style={{ borderColor: '#A9B1BE', borderLeft: 'none' }}\n        />\n      )\n    }\n    style={style}\n    value={value}\n  />\n);\n\nSearchBoxImpl.propTypes = {\n  containerProps: PropTypes.shape({}),\n  className: PropTypes.string,\n  innerRef: PropTypes.any,\n  style: PropTypes.objectOf(PropTypes.string),\n  placeholder: PropTypes.string,\n  onKeyUp: PropTypes.func,\n  onSearch: PropTypes.func,\n  onChange: PropTypes.func,\n  onBlur: PropTypes.func,\n  value: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.object,\n  ]),\n  showIcon: PropTypes.bool,\n  disabled: PropTypes.bool,\n  disableButton: PropTypes.bool,\n  readOnly: PropTypes.bool,\n  clearable: PropTypes.bool,\n};\n\nexport default withSearchable(SearchBoxImpl);\n","/* eslint-disable */\nimport createIcon from './utils/createIcon';\n\nexport default createIcon({\n  paths: [\n    'M12 10.5a.503.503 0 0 0-.109-.313l-4-5a.5013.5013 0 0 0-.703-.078c-.214.173-.25.488-.078.703l3.75 4.688-3.75 4.688c-.172.218-.136.531.078.703.216.172.53.138.703-.078l4-5A.501.501 0 0 0 12 10.5z',\n  ],\n  height: 20,\n  width: 20,\n});\n","/* eslint-disable */\nimport createIcon from './utils/createIcon';\n\nexport default createIcon({\n  paths: ['M7.5 12.875L4.625 10l-.875.875 3.75 3.75 8.75-8.75L15.375 5z'],\n  height: 20,\n  width: 20,\n});\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport SearchBoxImpl from './SearchBoxImpl';\n\nconst DSSearchBox = ({\n  containerProps = {},\n  innerRef = undefined,\n  className = '',\n  disabled = false,\n  disableButton = false,\n  searchIcon = 'search',\n  style = {},\n  property = 'all',\n  placeholder = 'Search all', // todo: i18nize this\n  searchOnEnter = true,\n  clearOnSearch = false,\n  onKeyUp = () => null,\n  onSearch = () => null,\n  onChange = () => null,\n  onBlur = () => null,\n  readOnly = false,\n  value = undefined,\n  showIcon = true,\n}) => (\n  <SearchBoxImpl\n    className={className}\n    clearOnSearch={clearOnSearch}\n    containerProps={containerProps}\n    disabled={disabled}\n    disableButton={disableButton}\n    innerRef={innerRef}\n    onKeyUp={onKeyUp}\n    onSearch={onSearch}\n    onChange={onChange}\n    onBlur={onBlur}\n    placeholder={placeholder}\n    property={property}\n    readOnly={readOnly}\n    searchIcon={searchIcon}\n    searchOnEnter={searchOnEnter}\n    showIcon={showIcon}\n    style={style}\n    value={value}\n  />\n);\n\nDSSearchBox.propTypes = {\n  containerProps: PropTypes.shape({}),\n  className: PropTypes.string,\n  innerRef: PropTypes.any,\n  /**\n   * Icon to use in the search button\n   */\n  searchIcon: PropTypes.string,\n  /**\n   * Set style to the search box\n   */\n  style: PropTypes.objectOf(PropTypes.string),\n  property: PropTypes.string,\n  /**\n   * Placeholder for the search box\n   */\n  placeholder: PropTypes.string,\n  /**\n   * Whether to trigger the search once the enter is pressed\n   */\n  searchOnEnter: PropTypes.bool,\n  /**\n   * Whether to clear the input on search\n   */\n  clearOnSearch: PropTypes.bool,\n  /**\n   * Allows a function that is triggered once in the search box a keyboard key is released\n   */\n  onKeyUp: PropTypes.func,\n  /**\n   * Allows a function that is triggered once the search is clicked\n   */\n  onSearch: PropTypes.func,\n  /**\n   * Allows a function that is triggered on change\n   */\n  onChange: PropTypes.func,\n  /**\n   * Function that is triggered on blur\n   */\n  onBlur: PropTypes.func,\n  /**\n   * Selected default active value\n   */\n  value: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n    PropTypes.object,\n  ]),\n  /**\n   * Whether to show an icon or not\n   */\n  showIcon: PropTypes.bool,\n  /**\n   * Disables the search input and button\n   */\n  disabled: PropTypes.bool,\n  /**\n   * Disables the search button\n   */\n  disableButton: PropTypes.bool,\n  readOnly: PropTypes.bool,\n};\n\nexport default DSSearchBox;\n","const ICONS_SIZES = {\n  XXS: 'xxs',\n  XS: 'xs',\n  S: 's',\n  M: 'm',\n  L: 'l',\n  XL: 'xl',\n  XXL: 'xxl',\n};\n\nexport default ICONS_SIZES;\n","import React, { cloneElement } from 'react';\n\nexport default (children, extraProps = {}) =>\n  React.Children.map(\n    children,\n    component =>\n      component\n        ? cloneElement(component, {\n            ...extraProps,\n            ...component.props,\n            className: `${component.props.className} toolbar-item`,\n          })\n        : component,\n    null,\n  );\n","import React from 'react';\nimport { aggregatedClasses } from '@elliemae/ds-classnames';\nimport styled from 'styled-components';\nimport DSSeparator from '../../Separator';\n\nconst blockName = 'menu-separator';\nconst Li = styled.li`\n  display: flex;\n  align-items: flex-start;\n  flex-direction: column;\n`;\n\nconst Title = aggregatedClasses('h5')(blockName, 'title');\nconst MenuSeparator = ({ title, showSeparator = true }) => (\n  <Li>\n    {showSeparator && <DSSeparator />}\n    {title && <Title>{title}</Title>}\n  </Li>\n);\n\nexport default MenuSeparator;\n","import { useMemo } from 'react';\n\nconst calculateHeight = (itemHeight, amountItemsInWindow, itemsLength) => {\n  const realAmountItemsInWindow =\n    itemsLength < amountItemsInWindow ? itemsLength : amountItemsInWindow;\n  return itemHeight * realAmountItemsInWindow;\n};\n\nexport default function useHeightByAmountOfItems({\n  itemHeight,\n  amountItems,\n  items,\n}) {\n  const calculatedHeight = useMemo(\n    () => calculateHeight(itemHeight, amountItems, items.length),\n    [amountItems, items],\n  );\n\n  return calculatedHeight;\n}\n","import React from 'react';\nimport { FixedSizeList as List } from 'react-window';\nimport useHeightByAmountOfItems from './utils/useHeightByAmountOfItems';\n\nconst MenuItem = ({ data, index, style }) => (\n  <div key={index} style={style}>\n    {data[index]}\n  </div>\n);\n\n// eslint-disable-next-line no-unused-vars\nfunction resolveComputation(items, cb, timeout = 1000) {\n  return () =>\n    new Promise(resolve => {\n      const doResolve = result => {\n        cb(result);\n        resolve(result);\n      };\n      let result = 0;\n      const timer = setTimeout(() => doResolve(result), timeout);\n      items.forEach(option => {\n        result =\n          option.props.label.length > result\n            ? option.props.label.length\n            : result;\n      });\n\n      clearTimeout(timer);\n      doResolve(result);\n    });\n}\n\nexport default function VirtualMenuList({\n  items,\n  itemHeight = 32,\n  amountItemsInWindow = 5,\n  width,\n  height,\n}) {\n  const computedListHeight = useHeightByAmountOfItems({\n    amountItems: amountItemsInWindow,\n    itemHeight,\n    items,\n  });\n\n  return (\n    <List\n      height={height || computedListHeight}\n      itemCount={items.length}\n      itemData={items}\n      itemSize={itemHeight}\n      width={width}\n    >\n      {MenuItem}\n    </List>\n  );\n}\n","import React from 'react';\n\nexport default React.createContext();\n","import React, { useEffect, useMemo, useState, useRef, useContext } from 'react';\nimport { aggregatedClasses } from '@elliemae/ds-classnames';\nimport { focusGroupManagerHoc } from '@elliemae/ds-shared/FocusGroup';\nimport PropTypes from 'prop-types';\nimport DSSearchBox from '../../form/SearchBox';\nimport VirtualMenuList from '../VirtualMenuList';\nimport MenuContext from '../MenuContext';\n\nconst SearchBoxWrapper = aggregatedClasses('div')(\n  'menu-search-group',\n  'search-wrapper',\n);\nconst NoOptionsWrapper = aggregatedClasses('div')(\n  'menu-search-group',\n  'no-options',\n);\n\nfunction SearchableGroup({\n  children,\n  amountItemsInWindow = 5,\n  searchTerm: searchTermProp = '',\n  noOptionsText = 'No options',\n  height,\n  width,\n  focusOnOpen = false,\n}) {\n  const searchRef = useRef(null);\n  const [searchTerm, setSearchTerm] = useState(searchTermProp);\n\n  useEffect(() => {\n    if (searchRef.current) searchRef.current.focus();\n  }, []);\n\n  const { visible } = useContext(MenuContext) || {};\n\n  useEffect(() => {\n    if (focusOnOpen && visible) {\n      setTimeout(() => {\n        if (searchRef.current) searchRef.current.focus();\n      }, 0);\n    }\n  }, [focusOnOpen, visible]);\n\n  const filteredChildren = useMemo(\n    () =>\n      children.filter(\n        child =>\n          !searchTerm ||\n          child.props.label.toLowerCase().startsWith(searchTerm.toLowerCase()),\n      ),\n    [children, searchTerm],\n  );\n\n  return (\n    <>\n      <SearchBoxWrapper>\n        <DSSearchBox\n          innerRef={searchRef}\n          onSearch={({ value }) => setSearchTerm(value)}\n          searchOnEnter={false}\n          showIcon={false}\n          value={searchTerm}\n        />\n      </SearchBoxWrapper>\n      {!filteredChildren.length && (\n        <NoOptionsWrapper>{noOptionsText}</NoOptionsWrapper>\n      )}\n      <VirtualMenuList\n        amountItemsInWindow={amountItemsInWindow}\n        height={height}\n        items={filteredChildren}\n        width={width}\n      />\n    </>\n  );\n}\n\nSearchableGroup.propTypes = {\n  /** The amount of items that are going to be rendered in the group */\n  amountItemsInWindow: PropTypes.number,\n  /** A search term */\n  searchTerm: PropTypes.string,\n  /** Text to show when there's no options to show */\n  noOptionsText: PropTypes.string,\n};\n\nexport default focusGroupManagerHoc(SearchableGroup);\n","import React from 'react';\nimport CheckableGroup from '@elliemae/ds-shared/CheckableGroup';\n\nfunction CheckboxGroup(props) {\n  return <CheckableGroup {...props} multi />;\n}\n\nCheckboxGroup.propTypes = {};\n\nexport default CheckboxGroup;\n","import React from 'react';\nimport CheckableGroup from '@elliemae/ds-shared/CheckableGroup';\n\nfunction RadioGroup(props) {\n  return <CheckableGroup {...props} multi={false} />;\n}\n\nRadioGroup.propTypes = {};\n\nexport default RadioGroup;\n","/* eslint-disable import/no-cycle */\nimport React, { useRef } from 'react';\nimport ChevronRight from '@elliemae/ds-icons/ChevronSmallRight';\nimport VerticalElipsis from '@elliemae/ds-icons/MoreOptionsVert';\nimport { useFocusGroupItem } from '@elliemae/ds-shared/FocusGroup';\nimport DSButton, { BUTTON_VARIANT } from '../../Button';\nimport DSPopper from '../../Popper';\nimport { useHiddenController } from '../../Hidden';\nimport Menu from '../Menu';\nimport MenuItem from './MenuItem';\n\nfunction SubMenu({\n  noAddon,\n  leftAddon = undefined,\n  label = undefined,\n  interactionType = 'hover',\n  children: subitems,\n  rightAddonType,\n  disabledAddonInactive,\n  checkableProps = {},\n  customRenderer,\n  onClick,\n  closeMenu,\n  id,\n}) {\n  const itemRef = useRef(null);\n  const focusOnOpen = useRef(false);\n  const { visible = false, onShow, onHide } = useHiddenController(undefined, {\n    interaction: 'click',\n  });\n\n  const { focusItemByNode } = useFocusGroupItem();\n  // todo: create a menu state to handle all related menu things\n  const handleShowSubItemsWithMouse = e => {\n    e.stopPropagation();\n    onShow();\n    focusOnOpen.current = true;\n  };\n  const handleShowWithMouse = e => {\n    if (onClick) onClick(e);\n  };\n  const handleShowWithMouseHover = () => {\n    onShow();\n    focusOnOpen.current = false;\n  };\n\n  const handleShowWithKeyboard = () => {\n    onShow();\n    focusOnOpen.current = true;\n  };\n\n  const hoverHandlers =\n    interactionType === 'hover'\n      ? {\n          onMouseEnter: handleShowWithMouseHover,\n          onMouseLeave: onHide,\n        }\n      : {\n          onClick: handleShowWithMouse,\n        };\n\n  const rightAddon =\n    rightAddonType === 'elipsis' ? (\n      <DSButton\n        aria-label=\"vertical-elipsis\"\n        buttonType=\"text\"\n        leftIcon={\n          <VerticalElipsis\n            className=\"submenu-arrow\"\n            color={['brand-primary', 600]}\n            size=\"s\"\n          />\n        }\n        onClick={e => handleShowSubItemsWithMouse(e)}\n        size=\"m\"\n        variant={BUTTON_VARIANT.DEFAULT}\n      />\n    ) : (\n      <ChevronRight\n        className=\"submenu-arrow\"\n        color={['brand-primary', 600]}\n        size=\"sm\"\n      />\n    );\n\n  return (\n    <>\n      <DSPopper\n        contentComponent={\n          <Menu\n            focusKeyBindings={{\n              ArrowLeft: [() => focusItemByNode(itemRef.current), 'exit'],\n            }}\n            focusOnOpen={focusOnOpen.current}\n            onExitFocusGroup={onHide}\n            {...hoverHandlers}\n            closeMenu={closeMenu}\n            visible={visible}\n          >\n            {subitems}\n          </Menu>\n        }\n        interactionType={interactionType}\n        isOpen={visible}\n        onOpen={opening => (opening ? onShow() : onHide())}\n        placement=\"right-start\"\n        showArrow={false}\n        triggerComponent={\n          <MenuItem\n            customRenderer={customRenderer}\n            disabledAddonInactive={disabledAddonInactive}\n            id={id}\n            innerRef={itemRef}\n            label={label}\n            leftAddon={leftAddon}\n            noAddon={noAddon}\n            {...hoverHandlers}\n            onKeyDown={e => {\n              if (\n                e.key === 'ArrowRight' ||\n                e.key === 'Enter' ||\n                e.keyCode === 32\n              ) {\n                handleShowWithKeyboard();\n              }\n            }}\n            rightAddon={rightAddon}\n            {...checkableProps}\n          />\n        }\n      />\n    </>\n  );\n}\n\nexport default SubMenu;\n","import React, { useMemo } from 'react';\nimport { useCheckableGroup } from '@elliemae/ds-shared/CheckableGroup';\nimport SearchableGroup from './SearchableGroup';\nimport { menuItemFactory } from './menuItemFactory';\nimport VirtualMenuList from '../VirtualMenuList';\n\nconst noop = () => null;\n\nfunction SelectionGroup({\n  multi = false,\n  searchable = false,\n  focusOnOpen = false,\n  onSelect = noop,\n  children,\n  items = undefined,\n  active = multi ? [] : '',\n  width,\n  height,\n}) {\n  const renderedItems = useMemo(\n    () =>\n      items &&\n      items.map(item => {\n        const Component = menuItemFactory(multi ? 'checkbox' : 'radio');\n        return (\n          <Component\n            {...item}\n            key={item.name || item.id || item.key}\n            item={item}\n            name={item.id || item.name}\n          />\n        );\n      }),\n    [items],\n  );\n  const decoratedGroupChildren = useCheckableGroup({\n    children: renderedItems || children,\n    multi,\n    active,\n    onCheck: onSelect,\n  });\n\n  if (searchable) {\n    return (\n      <SearchableGroup\n        focusOnOpen={focusOnOpen}\n        height={height}\n        items={items}\n        width={width}\n      >\n        {decoratedGroupChildren}\n      </SearchableGroup>\n    );\n  }\n  return (\n    <VirtualMenuList\n      height={height}\n      items={decoratedGroupChildren}\n      width={width}\n    />\n  );\n}\n\nexport default SelectionGroup;\n","import React from 'react';\nimport DSCheckbox from '../../form/Checkbox';\nimport MenuItemCheckable from './MenuItemCheckable';\n\nfunction MenuItemCheckbox({ checked, ...rest }) {\n  return (\n    <MenuItemCheckable\n      {...rest}\n      leftAddon={<DSCheckbox checked={checked} />}\n      role=\"menuitemcheckbox\"\n    />\n  );\n}\n\nexport default MenuItemCheckbox;\n","/* eslint-disable import/no-cycle */\nimport React from 'react';\nimport { isFunction } from '@elliemae/ds-utilities/utils';\n\nimport Separator from './Separator';\nimport MenuItem from './MenuItem';\nimport SubMenu from './SubMenu';\nimport SelectionGroup from './SelectionGroup';\nimport MenuItemCheckbox from './MenuItemCheckbox';\nimport MenuItemRadio from './MenuItemRadio';\n\nconst itemTypes = {\n  separator: Separator,\n  menuitem: MenuItem,\n  radio: MenuItemRadio,\n  checkbox: MenuItemCheckbox,\n  submenu: SubMenu,\n  'selection-group': SelectionGroup,\n};\n\nconst fallback = {\n  SelectionGroup: 'selection-group',\n};\n\nexport function menuItemFactory(\n  type = '',\n  items,\n  defaultItem = itemTypes.menuitem,\n) {\n  const itemsObject = items || itemTypes;\n  const parsedType = fallback[type] || type.toLowerCase();\n  return itemsObject[parsedType] || defaultItem;\n}\n\nexport function renderMenuItems(options, factory = menuItemFactory) {\n  return options.map((option, index) => {\n    if (isFunction(option.renderer)) {\n      return option.renderer({\n        key: option.id,\n        item: option,\n      });\n    }\n    const ItemComponent = factory(option.type);\n    const children =\n      option.subItems && renderMenuItems(option.subItems, factory);\n    return (\n      <ItemComponent\n        {...option}\n        key={option.id || index}\n        item={option}\n        onClick={null}\n        onMouseDown={option.onClick}\n        // onClick callback called in onMouseDown due to events order issue\n      >\n        {children}\n      </ItemComponent>\n    );\n  });\n}\n","/* eslint-disable import/no-cycle */\nimport React, { useRef, useMemo, useContext } from 'react';\nimport PropTypes from 'prop-types';\nimport { omit } from 'lodash';\nimport { aggregatedClasses } from '@elliemae/ds-classnames';\nimport { mergeRefs } from '@elliemae/ds-utilities/system';\nimport { useFocusGroupItem } from '@elliemae/ds-shared/FocusGroup';\nimport { runAll } from '@elliemae/ds-utilities/utils';\nimport DSTruncatedTooltipText from '../../TruncatedTooltipText';\nimport { renderMenuItems } from './menuItemFactory';\nimport SubMenu from './SubMenu';\nimport MenuContext from '../MenuContext';\n\nconst noop = () => null;\n\nconst blockName = 'menu-item';\n\nconst Content = aggregatedClasses('div')(blockName, 'content');\nconst Addon = aggregatedClasses('div')(\n  blockName,\n  'addon',\n  ({ empty, fixedItem }) => ({ empty, fixedItem }),\n);\n\nconst renderAddon = (addon, fixedItem, addonId) => (\n  <Addon key={addonId} classProps={{ fixedItem }}>\n    {addon}\n  </Addon>\n);\n\nconst renderAddons = (addons, fixedItem) =>\n  Array.isArray(addons)\n    ? addons.map(renderAddon)\n    : renderAddon(addons, fixedItem);\n\nconst Wrapper = aggregatedClasses('li')(\n  blockName,\n  null,\n  ({ disabled, disabledAddonInactive, customRenderer, fixedItem, type }) => ({\n    disabled,\n    disabledAddonInactive,\n    customRenderer,\n    fixedItem,\n    [`menu-type-${type}`]: type,\n  }),\n);\nconst calculateSize = (length = 0) => {\n  if (length > 45) return 45 * 7;\n  return length * 7;\n};\nfunction MenuItem(props) {\n  const {\n    innerRef,\n    as = 'li',\n    role = 'menuitem',\n    leftAddon = null,\n    rightAddon = undefined,\n    disabledAddonInactive = undefined,\n    label = undefined,\n    children,\n    tabIndex = -1,\n    onKeyDown = noop,\n    fixedItem = false,\n    noAddon,\n    disabled = false,\n    customRenderer,\n    maxOption,\n    closeMenu,\n    style,\n    ...otherProps\n  } = props;\n\n  const menuCxt = useContext(MenuContext);\n  const ref = useRef(null);\n  useFocusGroupItem(ref);\n  if (otherProps.subItems) {\n    return (\n      <SubMenu {...props} closeMenu={menuCxt.closeMenu}>\n        {renderMenuItems(otherProps.subItems)}\n      </SubMenu>\n    );\n  }\n\n  const wrapperProps = useMemo(() => omit(otherProps, ['icon']), [otherProps]);\n\n  const onClick = (...args) => {\n    if (wrapperProps.onClick) wrapperProps.onClick(...args);\n    if (wrapperProps.closeOnClick && menuCxt.closeMenu) {\n      menuCxt.closeMenu(...args);\n    }\n  };\n\n  return (\n    <Wrapper\n      as={as}\n      classProps={{\n        disabled,\n        disabledAddonInactive,\n        customRenderer,\n        fixedItem,\n        type: otherProps.type,\n      }}\n      id={otherProps.id}\n      innerRef={\n        otherProps.type !== 'disabled' ? mergeRefs(innerRef, ref) : innerRef\n      }\n      onKeyDown={\n        !fixedItem &&\n        runAll(e => {\n          if (e.key === ' ' || e.key === 'Enter') {\n            e.preventDefault();\n            e.target.dispatchEvent(\n              new MouseEvent('click', {\n                view: window,\n                bubbles: true,\n                cancelable: false,\n              }),\n            );\n          }\n        }, onKeyDown)\n      }\n      role={role}\n      style={style}\n      tabIndex={tabIndex}\n      {...wrapperProps}\n      onClick={onClick}\n    >\n      {!noAddon && renderAddons(leftAddon, fixedItem)}\n      {label && (\n        <Content\n          style={\n            maxOption > 0\n              ? {\n                  width: `${calculateSize(maxOption)}px`,\n                  maxWidth: `${calculateSize(maxOption)}px`,\n                }\n              : undefined\n          }\n        >\n          <DSTruncatedTooltipText value={label} />\n        </Content>\n      )}\n      {customRenderer}\n      {rightAddon && renderAddons(rightAddon)}\n      {children}\n    </Wrapper>\n  );\n}\n\nMenuItem.propTypes = {\n  /** Renders the MenuItem with a specific html element */\n  as: PropTypes.element,\n  /** Renders the passed element to the left */\n  leftAddon: PropTypes.element,\n  /** Renders the passed element to the right */\n  rightAddon: PropTypes.element,\n  /** Label for the menu item */\n  label: PropTypes.string,\n};\n\nexport default MenuItem;\n","/* eslint-disable import/no-cycle */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Checkmark from '@elliemae/ds-icons/Checkmark';\nimport { runAll } from '@elliemae/ds-utilities/utils';\nimport MenuItem from './MenuItem';\n\n// TODO: where to move this?\nfunction useCheckable({ checked }) {\n  return {\n    checked,\n    'aria-checked': checked,\n  };\n}\n\n/**\n * Reuses the same props as the MenuItem\n *\n * @param root0\n * @param root0.role\n * @param root0.checked\n * @param root0.name\n * @param root0.checkIcon\n * @param root0.children\n * @param root0.leftAddon\n * @param root0.item\n */\nfunction MenuItemCheckable({\n  role = 'menuitemcheckbox',\n  checked = false,\n  name = '',\n  checkIcon = <Checkmark color={['brand-primary', 600]} />,\n  children,\n  leftAddon,\n  item = undefined,\n  ...otherProps\n}) {\n  const checkableProps = useCheckable({ checked, name });\n  const handleClick = () =>\n    runAll(otherProps.onClick, checkableProps.onClick)(\n      { target: { value: name, checked } },\n      item,\n    );\n\n  const checkAddon =\n    leftAddon ||\n    (checkableProps.checked ? (\n      <div className=\"checkable-mark\">{checkIcon}</div>\n    ) : (\n      <div />\n    ));\n  return (\n    <MenuItem\n      {...item}\n      {...otherProps}\n      {...checkableProps}\n      customRenderer={\n        item && item.customRenderer ? item.customRenderer : () => {}\n      }\n      items={otherProps.subItems}\n      leftAddon={checkAddon}\n      onClick={handleClick}\n      role={role}\n    />\n  );\n}\n\nMenuItemCheckable.propTypes = {\n  /** Whether the item is checked or not */\n  checked: PropTypes.bool,\n  /** A custom item when the item is checked */\n  checkIcon: PropTypes.element,\n};\nexport default MenuItemCheckable;\n","import React from 'react';\nimport MenuItemCheckable from './MenuItemCheckable';\n\nfunction MenuItemRadio(props) {\n  return <MenuItemCheckable {...props} role=\"menuitemradio\" />;\n}\n\nMenuItemRadio.propTypes = {\n  ...MenuItemCheckable.propTypes,\n};\n\nexport default MenuItemRadio;\n","/* eslint-disable max-lines */\n/* eslint-disable react/prop-types */\n/* eslint-disable import/no-cycle */\nimport React, { useContext, useEffect, useMemo, useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { omit } from 'lodash';\nimport { aggregatedClasses } from '@elliemae/ds-classnames';\nimport { animated } from 'react-spring/web.cjs';\nimport { useOnClickOutside } from '@elliemae/ds-utilities/hooks';\nimport { mergeRefs } from '@elliemae/ds-utilities/system';\nimport {\n  focusGroupManagerHoc,\n  FocusGroupContext,\n} from '@elliemae/ds-shared/FocusGroup';\nimport { useHiddenTransition } from '../Hidden';\nimport MenuItemRadio from './MenuItems/MenuItemRadio';\nimport MenuItemCheckbox from './MenuItems/MenuItemCheckbox';\nimport CheckboxGroup from './MenuItems/CheckboxGroup';\nimport RadioGroup from './MenuItems/RadioGroup';\nimport Separator from './MenuItems/Separator';\nimport MenuItem from './MenuItems/MenuItem';\nimport SubMenu from './MenuItems/SubMenu';\nimport SearchableGroup from './MenuItems/SearchableGroup';\nimport SelectionGroup from './MenuItems/SelectionGroup';\nimport { renderMenuItems, menuItemFactory } from './MenuItems/menuItemFactory';\nimport MenuContext from './MenuContext';\n\nconst RESPONSIVE_HEIHGT_MARGIN = 120;\n\nconst blockName = 'menu';\n\nconst noop = () => {};\n\nconst MenuComponent = aggregatedClasses('div')(\n  blockName,\n  '',\n  ({ menuComboBox, type }) => ({\n    'menu-combo-box': menuComboBox,\n    [`type-${type}`]: type,\n  }),\n);\n\n/**\n * todo: -- IDEA -- each menu could have an overlay based on an overlay stack context so we can\n * capture the context of the clicks on very nested components\n */\n\nconst isChildOfType = (child, type) => child.type.name === type;\n\nfunction DSMenu({\n  containerProps = {},\n  innerRef,\n  as: MenuTag = animated.ul,\n  children = undefined,\n  onClickOutside = noop,\n  // handlers from hidden\n  visible = undefined,\n  focusOnOpen = false,\n  maxOption = 0,\n  style = {},\n  minWidth = undefined,\n  maxWidth = undefined,\n  closeMenu,\n  responsiveHeight = false,\n  ...otherProps\n}) {\n  const menuRef = useRef(null);\n  const { focusFirst } = useContext(FocusGroupContext);\n  const { destroyed, ...hiddenProps } = useHiddenTransition({ visible, style });\n\n  // force no addon to the children if the menu doesn't have any item with leftAddon like SelectionGroup\n  const nextChildren = useMemo(() => {\n    const forceLeftAddon = React.Children.toArray(children).some(\n      (child) =>\n        isChildOfType(child, 'SelectionGroup') ||\n        isChildOfType(child, 'MenuItemCheckbox') ||\n        isChildOfType(child, 'MenuItemRadio') ||\n        child.props.leftAddon,\n    );\n\n    return React.Children.map(\n      children,\n      (child) =>\n        child &&\n        React.cloneElement(child, {\n          ...child.props,\n          noAddon: !forceLeftAddon ? true : undefined,\n          maxOption,\n          closeMenu,\n        }),\n    );\n  }, [children]);\n\n  useOnClickOutside(menuRef, onClickOutside);\n\n  useEffect(() => {\n    if (focusOnOpen && visible) {\n      setTimeout(() => {\n        focusFirst();\n      }, 0);\n    }\n  }, [visible, focusOnOpen]);\n  // todo: find out a better approach to this\n  return !hiddenProps.destroyed ? (\n    <MenuContext.Provider value={{ visible, closeMenu }}>\n      <MenuComponent\n        data-testid=\"em-ds-menu\"\n        {...containerProps}\n        as={MenuTag}\n        classProps={{ ...(otherProps.classProps || {}), type: otherProps.type }}\n        innerRef={mergeRefs(innerRef, menuRef)}\n        role=\"menu\"\n        {...omit(otherProps, ['scheduleUpdate'])}\n        {...hiddenProps}\n      >\n        {/* eslint-disable indent */}\n        <div\n          className=\"menu-component-internal-wrapper\"\n          style={{\n            ...style,\n            minWidth,\n            maxWidth,\n            ...(responsiveHeight\n              ? {\n                  overflowY: 'scroll',\n                  maxHeight: responsiveHeight\n                    ? `${window.innerHeight - RESPONSIVE_HEIHGT_MARGIN}px`\n                    : undefined,\n                }\n              : {}),\n          }}\n        >\n          {/* eslint-enable indent */}\n          {nextChildren}\n        </div>\n      </MenuComponent>\n    </MenuContext.Provider>\n  ) : null;\n}\n\nconst WrappedMenu = focusGroupManagerHoc(DSMenu, { loop: true });\n\nDSMenu.propTypes = {\n  containerProps: PropTypes.shape({}),\n  /** Renders the menu with a specific html element */\n  as: PropTypes.element,\n  /** Handler when a user clicks outside the menu */\n  onClickOutside: PropTypes.func,\n  /** Whether the menu is visible or not */\n  visible: PropTypes.bool,\n  /** When set to true, it's going to focus the first item */\n  focusOnOpen: PropTypes.bool,\n  /** Customize menu minWidth. Can be undefined or 'number' */\n  minWidth: PropTypes.number,\n  /** Customize menu maxWidth. Can be undefined or 'number' */\n  maxWidth: PropTypes.number,\n};\n\n// todo: add a handler to get this kind of exports for documentation\nWrappedMenu.Item = MenuItem;\nWrappedMenu.ItemCheckbox = MenuItemCheckbox;\nWrappedMenu.ItemRadio = MenuItemRadio;\nWrappedMenu.SubMenu = SubMenu;\nWrappedMenu.Separator = Separator;\nWrappedMenu.CheckboxGroup = CheckboxGroup;\nWrappedMenu.RadioGroup = RadioGroup;\nWrappedMenu.SearchableGroup = SearchableGroup;\nWrappedMenu.SelectionGroup = SelectionGroup;\n\nexport { menuItemFactory, renderMenuItems };\nexport default WrappedMenu;\n","import { useRef } from 'react';\n\nexport default function useExecutionDelay(startFn, cleanFn, delayTime) {\n  const startTimer = useRef();\n  const closeTimer = useRef();\n\n  const startFunction = (...args) => {\n    clearTimeout(closeTimer.current);\n    startTimer.current = setTimeout(() => startFn(...args), delayTime);\n  };\n\n  const cleanFunction = (...args) => {\n    clearTimeout(startTimer.current);\n    closeTimer.current = setTimeout(() => cleanFn(...args), 30);\n  };\n  return [startFunction, cleanFunction];\n}\n","/* eslint-disable react/display-name */\nimport React from 'react';\nimport FocusGroupManager from './FocusGroupManager';\n\nexport default function FocusGroupHoc(WrappedComponent, options = {}) {\n  return ({\n    onExitFocusGroup,\n    onFocusPrevGroup,\n    focusKeyBindings,\n    ...props\n  }) => (\n    <FocusGroupManager\n      keyBindings={focusKeyBindings}\n      onExitFocusGroup={onExitFocusGroup}\n      onFocusPrevGroup={onFocusPrevGroup}\n      {...options}\n    >\n      <WrappedComponent {...props} {...options} />\n    </FocusGroupManager>\n  );\n}\n","import React from 'react';\n\nexport default React.createContext();\n","/* eslint-disable react/prop-types */\n/* eslint-disable indent */\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { runAll, toggleInObject } from '@elliemae/ds-utilities/utils';\nimport DropdownMenuContext from './DropdownMenuContext';\n\nconst noop = () => null;\n\nfunction DropdownMenuProvider({\n  onSelectMenuItem = noop,\n  onOpenMenu = noop,\n  onClose,\n  children,\n  isOpen,\n  selection,\n  singleGroupSelection,\n  onSelectChange = noop,\n}) {\n  const [isMenuOpen, setMenuOpen] = useState(isOpen);\n\n  const closeMenu = useCallback(() => {\n    setMenuOpen(false);\n    onOpenMenu(false);\n    onClose();\n  });\n  const openMenu = useCallback(() => {\n    setMenuOpen(true);\n    onOpenMenu(true);\n  });\n\n  const handleItemClick = ({ item, group }) => {\n    let activeState;\n    // reset selection if single selection group is activated\n    let nextSelection = !singleGroupSelection ? selection : {};\n\n    if (group) {\n      activeState = group.active;\n      nextSelection = {\n        ...nextSelection,\n        [group.id]: activeState,\n      };\n    } else {\n      const selectionItem = group || item;\n      activeState = selectionItem.active || selectionItem.checked;\n\n      // can be toggled (radio with unselection)\n      nextSelection = Array.isArray(activeState)\n        ? {\n            ...nextSelection,\n            [selectionItem.id]: activeState,\n          }\n        : toggleInObject(\n            nextSelection,\n            selectionItem.id,\n            item.label || activeState || true,\n          );\n    }\n    onSelectChange({\n      item,\n      group,\n      selection: nextSelection,\n    });\n    // todo: just pass item on item and group when selection callback,\n    //  use onSelectchange for nextSelection\n    onSelectMenuItem(item, activeState, nextSelection);\n  };\n\n  const handleCloseOnClick = useCallback(({ item, group = {} }) => {\n    if (item.closeOnClick !== undefined) {\n      if (item.closeOnClick) closeMenu();\n      return;\n    }\n    if (group.closeOnClick !== undefined) {\n      if (group.closeOnClick) closeMenu();\n    }\n  }, []);\n\n  const valueProvider = useMemo(\n    () => ({\n      onItemClick: runAll(handleItemClick, handleCloseOnClick),\n      closeMenu,\n      openMenu,\n      isMenuOpen,\n      selection,\n    }),\n    [isMenuOpen, selection],\n  );\n  return (\n    <DropdownMenuContext.Provider value={valueProvider}>\n      {children}\n    </DropdownMenuContext.Provider>\n  );\n}\n\nexport default DropdownMenuProvider;\n","/* eslint-disable react/display-name */\nimport React, { useContext } from 'react';\nimport { runAll, get } from '@elliemae/ds-utilities/utils';\nimport DropdownMenuContext from './DropdownMenuContext';\n\nconst noop = () => null;\n\nfunction MenuItemGroupSelectionHOC(WrappedComponent, handlerName = 'onSelect') {\n  return ({ item = {}, ...restProps }) => {\n    const { onItemClick, selection } = useContext(DropdownMenuContext);\n    const propHandler = restProps[handlerName] || noop;\n    const handler = {\n      [handlerName]: (active, itemOption) =>\n        runAll(\n          item.onSelect,\n          onItemClick,\n          propHandler,\n        )({ item: itemOption, group: { ...item, active } }),\n    };\n    return (\n      <WrappedComponent\n        {...restProps}\n        {...(selection\n          ? { active: get(selection, [item.id]) || item.active }\n          : {})}\n        {...handler}\n      />\n    );\n  };\n}\n\nexport default MenuItemGroupSelectionHOC;\n","/* eslint-disable react/display-name */\nimport React, { useContext } from 'react';\nimport { runAll, get } from '@elliemae/ds-utilities/utils';\nimport DropdownMenuContext from './DropdownMenuContext';\n\nconst noop = () => null;\n\nconst defaultConfig = { type: 'default', handlerName: 'onClick' };\n\nfunction MenuItemClickableHOC(WrappedComponent, config) {\n  return ({ item = {}, ...restProps }) => {\n    const { type, handlerName } = { ...defaultConfig, ...config };\n    const { onItemClick, selection } = useContext(DropdownMenuContext);\n    const propHandler = restProps[handlerName] || noop;\n    const handler = {\n      [handlerName]: () => runAll(onItemClick, propHandler)({ item, type }),\n    };\n    return (\n      <WrappedComponent\n        {...restProps}\n        {...(type === 'selectable' && selection\n          ? { checked: get(selection, [item.id]) }\n          : {})}\n        {...handler}\n      />\n    );\n  };\n}\n\nexport default MenuItemClickableHOC;\n","import {\n  Menu,\n  renderMenuItems,\n  menuItemFactory,\n} from '@elliemae/ds-basic/Menu';\n\nimport MenuItemClickableHOC from './MenuItemClickableHOC';\nimport MenuItemGroupSelectionHOC from './MenuItemGroupSelectionHOC';\n\nconst itemTypes = {\n  separator: Menu.Separator,\n  menuitem: MenuItemClickableHOC(Menu.Item),\n  radio: MenuItemClickableHOC(Menu.ItemRadio, { type: 'selectable' }),\n  checkbox: MenuItemClickableHOC(Menu.ItemCheckbox, { type: 'selectable' }),\n  submenu: Menu.SubMenu,\n  'selection-group': MenuItemGroupSelectionHOC(Menu.SelectionGroup),\n};\n\nexport const factory = type =>\n  menuItemFactory(type, itemTypes, itemTypes.menuitem);\nexport const renderOptions = options => renderMenuItems(options, factory);\n","import React from 'react';\nimport styled from 'styled-components';\nimport { DSCircularProgressIndicator } from '@elliemae/ds-basic/CircularProgressIndicator';\n\nconst Wrapper = styled.div`\n  display: flex;\n  justify-content: center;\n  height: 56px;\n`;\n\nconst LoadingIndicator = () => (\n  <Wrapper>\n    <DSCircularProgressIndicator size=\"m\" />\n  </Wrapper>\n);\n\nexport default LoadingIndicator;\n","import React, { useContext, useEffect, useMemo, useState } from 'react';\nimport getComponentFromProps from '@elliemae/ds-utilities/getComponentFromProps';\nimport DSPopper from '@elliemae/ds-basic/Popper';\nimport { Menu } from '@elliemae/ds-basic/Menu';\nimport { convertPropToCssClassName } from '@elliemae/ds-classnames';\nimport { runAll, isFunction } from '@elliemae/ds-utilities/utils';\nimport DropdownMenuContext from './DropdownMenuContext';\nimport { renderOptions, factory } from './decoratedMenuItemFactory';\nimport LoadingIndicator from './DropdownMenuLoadingIndicator';\n\nconst blockName = 'menu';\n\nconst getMax = options => {\n  let max = 0;\n  options.forEach(o => {\n    if (o && o.label && String(o.label).length > max)\n      max = String(o.label).length;\n  });\n  return max;\n};\n\nconst DropdownMenuRenderer = ({\n  containerProps,\n  className,\n  options = [],\n  triggerComponent,\n  placement,\n  interactionType,\n  preventOverflow,\n  customMenu,\n  contentOffset,\n  contentStyle,\n  isOpen,\n  children,\n  menuProps,\n  referenceNode,\n  focusOnOpen: focusOnOpenProp,\n  onClickOutsideMenu,\n  responsiveHeight,\n  itemsRenderer,\n  maxWidth,\n  minWidth,\n  zIndex,\n  type,\n  loading,\n}) => {\n  const [focusOnOpen, setFocusOnOpenMenu] = useState(focusOnOpenProp);\n  const { isMenuOpen, openMenu, closeMenu } = useContext(DropdownMenuContext);\n  const maxOption = useMemo(() => {\n    let max = 0;\n    options.forEach(o => {\n      if (o && o.label && String(o.label).length > max)\n        max = String(o.label).length;\n      if (o && o.items) {\n        const nestedMax = getMax(o.items);\n        if (nestedMax > max) max = nestedMax;\n      }\n    });\n    return max;\n  }, [options]);\n\n  const optionsRendererd = useMemo(() => {\n    if (options[0] && options[0].type === 'separator') {\n      options[0].showSeparator = false;\n    }\n    return isFunction(itemsRenderer)\n      ? itemsRenderer(options, factory)\n      : renderOptions(options);\n  }, [options]);\n\n  const dropdownBlockName = convertPropToCssClassName(blockName);\n\n  const menuContent = () => {\n    if (loading) return <LoadingIndicator />;\n    if (children) return children;\n    if (optionsRendererd) return optionsRendererd;\n  };\n\n  const MenuComponent = customMenu ? (\n    getComponentFromProps(customMenu, {\n      options,\n      focusOnOpen,\n      maxOption,\n      ...menuProps,\n      closeMenu,\n      loading,\n    })\n  ) : (\n    <Menu\n      closeMenu={closeMenu}\n      focusOnOpen={focusOnOpen}\n      maxOption={type === 'phone' ? maxOption : undefined}\n      maxWidth={maxWidth}\n      minWidth={minWidth}\n      onClickOutside={onClickOutsideMenu}\n      onExitFocusGroup={closeMenu}\n      responsiveHeight={responsiveHeight}\n      type={type}\n      visible\n      {...menuProps}\n    >\n      {menuContent()}\n    </Menu>\n  );\n\n  useEffect(() => {\n    setFocusOnOpenMenu(focusOnOpenProp);\n  });\n\n  return (\n    <DSPopper\n      blockName={dropdownBlockName}\n      containerProps={containerProps}\n      contentComponent={MenuComponent}\n      contentOffset={contentOffset}\n      contentStyle={contentStyle}\n      interactionType={interactionType}\n      isOpen={isOpen !== undefined ? isOpen : isMenuOpen}\n      onOpen={opening => (opening ? openMenu() : closeMenu())}\n      placement={placement}\n      preventOverflow={preventOverflow}\n      referenceNode={referenceNode}\n      showArrow={false}\n      triggerComponent={getComponentFromProps(triggerComponent, {\n        onClick:\n          interactionType === 'hover'\n            ? runAll(openMenu, triggerComponent.props.onClick)\n            : runAll(\n                !isMenuOpen ? openMenu : closeMenu,\n                triggerComponent.props.onClick,\n              ),\n        onMouseEnter: interactionType === 'hover' ? openMenu : undefined,\n        onKeyDown: e => {\n          if (e.key === 'ArrowDown' || e.key === ' ') {\n            e.preventDefault();\n            setFocusOnOpenMenu(true);\n            openMenu();\n          }\n        },\n        className: `${triggerComponent.props.className} ${className}`,\n      })}\n      zIndex={zIndex || menuProps.zIndex}\n    />\n  );\n};\n\nexport default DropdownMenuRenderer;\n","import React from 'react';\nimport DropdownMenuProvider from './DropdownMenuProvider';\nimport DropdownMenuRenderer from './DropdownMenuRenderer';\n\nfunction DropdownMenuWrapper(props) {\n  return (\n    <DropdownMenuProvider {...props}>\n      <DropdownMenuRenderer {...props} />\n    </DropdownMenuProvider>\n  );\n}\n\nexport default DropdownMenuWrapper;\n","export const Position = {\n  AUTO: 'auto',\n  AUTO_START: 'auto-start',\n  AUTO_END: 'auto-end',\n  BOTTOM: 'bottom',\n  BOTTOM_START: 'bottom-start',\n  BOTTOM_END: 'bottom-end',\n  LEFT: 'left',\n  LEFT_END: 'left-end',\n  LEFT_START: 'left-start',\n  RIGHT: 'right',\n  RIGHT_END: 'right-end',\n  RIGHT_START: 'right-start',\n  TOP: 'top',\n  TOP_START: 'top-start',\n  TOP_END: 'top-end',\n};\n\nexport const positions = [\n  Position.AUTO_START,\n  Position.AUTO_END,\n  Position.AUTO,\n  Position.TOP_START,\n  Position.TOP,\n  Position.TOP_END,\n  Position.RIGHT_START,\n  Position.RIGHT,\n  Position.RIGHT_END,\n  Position.BOTTOM_START,\n  Position.BOTTOM,\n  Position.BOTTOM_END,\n  Position.LEFT_START,\n  Position.LEFT,\n  Position.LEFT_END,\n];\n","export const Interaction = {\n  CLICK: 'click',\n  HOVER: 'hover',\n};\n\nexport const interactions = [Interaction.CLICK, Interaction.HOVER];\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { TooltipTextProvider } from '@elliemae/ds-basic/TruncatedTooltipText';\n// todo: docgen handlers at the moment don't get data from alias\nimport { positions, Position } from '../../../ds-basic/src/Popper/positions';\nimport {\n  interactions,\n  Interaction,\n} from '../../../ds-basic/src/Popper/interaction';\nimport DropdownMenuWrapper from './DropdownMenuWrapper';\n\nconst noop = () => null;\n\nconst DSDropdownMenu = ({\n  containerProps = {},\n  className = '',\n  contentStyle = null,\n  options = [],\n  onSelectMenuItem = noop,\n  onOpenMenu = noop,\n  onClickOutsideMenu = noop,\n  preventOverflow = 'viewport',\n  placement = Position.BOTTOM_START,\n  interactionType = Interaction.CLICK,\n  triggerComponent = noop,\n  customMenu = null,\n  isOpen = undefined,\n  selection = {},\n  menuProps = {},\n  referenceNode = undefined,\n  focusOnOpen = false,\n  onClose = noop,\n  itemsRenderer = undefined,\n  responsiveHeight = false,\n  singleGroupSelection = false,\n  onSelectChange = noop,\n  minWidth = undefined,\n  maxWidth = undefined,\n  zIndex,\n  type,\n  loading = false,\n}) => (\n  <TooltipTextProvider>\n    <DropdownMenuWrapper\n      className={className}\n      containerProps={containerProps}\n      contentStyle={contentStyle}\n      customMenu={customMenu}\n      focusOnOpen={focusOnOpen}\n      interactionType={interactionType}\n      isOpen={isOpen}\n      itemsRenderer={itemsRenderer}\n      maxWidth={maxWidth}\n      menuProps={menuProps}\n      minWidth={minWidth}\n      onClickOutsideMenu={onClickOutsideMenu}\n      onClose={onClose}\n      onOpenMenu={onOpenMenu}\n      onSelectChange={onSelectChange}\n      onSelectMenuItem={onSelectMenuItem}\n      options={options}\n      placement={placement}\n      preventOverflow={preventOverflow}\n      referenceNode={referenceNode}\n      responsiveHeight={responsiveHeight}\n      selection={selection}\n      singleGroupSelection={singleGroupSelection}\n      triggerComponent={triggerComponent}\n      type={type}\n      zIndex={zIndex}\n      loading={loading}\n    />\n  </TooltipTextProvider>\n);\n\nDSDropdownMenu.propTypes = {\n  containerProps: PropTypes.shape({}),\n  /** Object style passed to the menu */\n  contentStyle: PropTypes.shape({}),\n  /** Options items for the dropdown menu. Check menu item types */\n  options: PropTypes.arrayOf(\n    PropTypes.shape({\n      type: PropTypes.string,\n      id: PropTypes.string,\n      label: PropTypes.string,\n    }),\n  ),\n  /** Handler when user clicks on a menu item */\n  onSelectMenuItem: PropTypes.func,\n  /** Handler when the menu shows up */\n  onOpenMenu: PropTypes.func,\n  /** Handler when user clicks outside the menu */\n  onClickOutsideMenu: PropTypes.func,\n  /** Prevent to move the menu outside of the container defined when interacting with the page */\n  preventOverflow: PropTypes.oneOf(['viewport', 'scrollParent', 'window']),\n  /** Menu placement */\n  placement: PropTypes.oneOf(positions),\n  /** How to open the menu with click, hover */\n  interactionType: PropTypes.oneOf(interactions),\n  /** The component that is going to open / close the menu */\n  triggerComponent: PropTypes.element,\n  /** Custom menu component */\n  customMenu: PropTypes.element,\n  /** Whether the menu is open or not */\n  isOpen: PropTypes.bool,\n  /** Selection state. Ex: { [itemId]: '{bool}', [idMultiSelectionItem]: '{string}' } */\n  selection: PropTypes.shape({}),\n  /** Props object passed to the menu component */\n  menuProps: PropTypes.shape({}),\n  /** Customize the items render */\n  itemsRenderer: PropTypes.func,\n  /** Customize menu format. Can be undefined or 'phone' */\n  type: PropTypes.string,\n  /** Customize menu minWidth. Can be undefined or 'number' */\n  minWidth: PropTypes.number,\n  /** Customize menu maxWidth. Can be undefined or 'number' */\n  maxWidth: PropTypes.number,\n  /** Make the menu responsive, it uses a margin of 120 px */\n  responsiveHeight: PropTypes.bool,\n  /** Customize menu zIndex. Can be undefined or 'number' */\n  zIndex: PropTypes.number,\n  className: PropTypes.string,\n  focusOnOpen: PropTypes.bool,\n  loading: PropTypes.bool,\n  referenceNode: PropTypes.any,\n  onClose: PropTypes.func,\n  onSelectChange: PropTypes.func,\n  singleGroupSelection: PropTypes.bool,\n};\n\nexport default DSDropdownMenu;\n","import React, { useRef } from 'react';\nimport PropTypes from 'prop-types';\nimport { aggregatedClasses } from '@elliemae/ds-classnames';\nimport FocusGroupProvider from '@elliemae/ds-shared/FocusGroup/FocusGroupManager';\nimport { mergeRefs } from '@elliemae/ds-utilities/system';\nimport decorateToolbarChildren from './decorateToolbarChildren';\nimport Item from './ToolbarItem';\nimport ToolbarGroup from './ToolbarGroup';\nimport Divider from './ToolbarDivider';\n\nconst blockName = 'toolbar';\n\nconst ToolbarContainer = aggregatedClasses('div')(\n  blockName,\n  null,\n  ({ withDepth, alignment, size }) => ({\n    'without-depth': !withDepth,\n    [alignment]: !!alignment,\n    [size]: size,\n  }),\n);\n\nconst DSToolbar = ({\n  containerProps = {},\n  innerRef,\n  withDepth = true,\n  alignment = 'right', // left || right\n  autoFocusOnMount = true,\n  children = [],\n  size = 'normal',\n  ...otherProps\n}) => {\n  const containerRef = useRef(null);\n  return (\n    <FocusGroupProvider\n      autoFocusOnMount={autoFocusOnMount}\n      getContainer={() => containerRef.current}\n      keyBindings={{\n        Tab: 'next',\n      }}\n      orientation=\"horizontal\"\n    >\n      <ToolbarContainer\n        {...containerProps}\n        {...otherProps}\n        classProps={{ withDepth, alignment, size }}\n        innerRef={mergeRefs(innerRef, containerRef)}\n      >\n        {decorateToolbarChildren(children)}\n      </ToolbarContainer>\n    </FocusGroupProvider>\n  );\n};\n\nDSToolbar.propTypes = {\n  containerProps: PropTypes.shape({}),\n  /** Shows a shadow rear the toolbar */\n  withDepth: PropTypes.bool,\n  /** Aligns the toolbar to the left or right */\n  alignment: PropTypes.oneOf(['right', 'left']),\n  /** Toolbar size */\n  size: PropTypes.oneOf(['normal', 'compact']),\n};\n\nexport { Item as ToolbarItem, ToolbarGroup, Divider as ToolbarDivider };\n\nexport default DSToolbar;\n","export const SearchableTreePlugin = 'tree-searchable';\n"],"sourceRoot":""}